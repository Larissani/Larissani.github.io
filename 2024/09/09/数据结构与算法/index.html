<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构与算法 | larissa的小宇宙</title><meta name="author" content="Larissa"><meta name="copyright" content="Larissa"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 复杂性分析常用表示方法Big O Notation  算法运行时间的上界。因此，给出了算法的最坏情况复杂度。 O(g(n)) &#x3D; &#123; f(n): 存在正整数c 和 n0 使得 0 ≤ f(n) ≤ cg(n) 对于 n ≥ n0 &#125; 时间复杂度算法的时间复杂度定义为算法运行所需的时间量，作为输入长度的函数。请注意，运行时间是输入长度的函数，而不是算法运行所在机器的实">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="http://example.com/2024/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="larissa的小宇宙">
<meta property="og:description" content="[TOC] 复杂性分析常用表示方法Big O Notation  算法运行时间的上界。因此，给出了算法的最坏情况复杂度。 O(g(n)) &#x3D; &#123; f(n): 存在正整数c 和 n0 使得 0 ≤ f(n) ≤ cg(n) 对于 n ≥ n0 &#125; 时间复杂度算法的时间复杂度定义为算法运行所需的时间量，作为输入长度的函数。请注意，运行时间是输入长度的函数，而不是算法运行所在机器的实">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imge.cc/2024/09/06/66d9e1e8bfa67.jpg">
<meta property="article:published_time" content="2024-09-09T07:35:48.000Z">
<meta property="article:modified_time" content="2025-01-12T13:49:16.463Z">
<meta property="article:author" content="Larissa">
<meta property="article:tag" content="cs61b acwing">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imge.cc/2024/09/06/66d9e1e8bfa67.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-12 21:49:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imge.cc/2024/09/05/66d9a7e532c09.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-layer-group"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-paper-plane"></i><span> 关于本人</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic.imge.cc/2024/09/06/66d9e1e8bfa67.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="larissa的小宇宙"><span class="site-name">larissa的小宇宙</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-layer-group"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-paper-plane"></i><span> 关于本人</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-09T07:35:48.000Z" title="发表于 2024-09-09 15:35:48">2024-09-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-12T13:49:16.463Z" title="更新于 2025-01-12 21:49:16">2025-01-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="复杂性分析"><a href="#复杂性分析" class="headerlink" title="复杂性分析"></a>复杂性分析</h1><h2 id="常用表示方法"><a href="#常用表示方法" class="headerlink" title="常用表示方法"></a>常用表示方法</h2><p>Big O Notation  算法运行时间的上界。因此，给出了算法的最坏情况复杂度。</p>
<p><code>O(g(n)) = &#123; f(n): 存在正整数c 和 n0 使得 0 ≤ f(n) ≤ cg(n) 对于 n ≥ n0 &#125;</code></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>算法的时间复杂度定义为算法运行所需的时间量，作为输入长度的函数。请注意，运行时间是输入长度的函数，而不是算法运行所在机器的实际执行时间</p>
<p>为了估计时间复杂度，我们需要考虑每条基本指令的成本和指令执行的次数。</p>
<ul>
<li><p>如果语句具有<em><strong>比较、返回语句、赋值和读取变量等基本操作。我们可以假设它们每O(1)花费常数时间</strong></em></p>
<p><code>T(n) = t(statement1) + t(statement2) + ... + t(statementN); </code><br>总之 <em><strong>T(n) &#x3D; O(1)</strong></em> 因为复杂度是恒定的</p>
</li>
<li><p>对于任何循环，我们找出其中的<em><strong>循环 内语句的运行时间（包括条件测试），并将其乘以迭代的次数</strong></em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;这里有很多简单地执行语句&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这个程序会执行n 次，所以 这个程序所花费的时间是(线性复杂度)：<br>  <code>T(n) = n * (t(statement1)...)   = n* O(1)   = O(n)</code><br>如果嵌套循环，比如第一个循环n 次，第二个循环m 次。 T(n) &#x3D; n<em>m</em>(t(statement)..)&#x3D;&#x3D;O(n*m) </p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>定义： 算法解决问题所需要的把内存量。<br>一个算法的空间复杂度是该<em><strong>算法相对于输入大小所占用的总空间</strong></em>。空间复杂度包括辅助空间和输入使用的空间。与时间复杂度是平行概念。</p>
<hr>
<h1 id="数组，链表"><a href="#数组，链表" class="headerlink" title="数组，链表"></a>数组，链表</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val:<span class="built_in">int</span></span>): </span><br><span class="line">        <span class="variable language_">self</span>.val : <span class="built_in">int</span> = val  <span class="comment">#值</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> :ListNode | <span class="literal">None</span>  = <span class="literal">None</span> <span class="comment">#后继节点的引用</span></span><br><span class="line">        <span class="variable language_">self</span>.prev : ListNode | <span class="literal">None</span> = <span class="literal">None</span> <span class="comment"># 前驱节点引用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;初始化链表&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 初始化链表 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4</span></span><br><span class="line"><span class="comment"># 初始化各个节点</span></span><br><span class="line">n0 = ListNode(<span class="number">1</span>)</span><br><span class="line">n1 = ListNode(<span class="number">3</span>)</span><br><span class="line">n2 = ListNode(<span class="number">2</span>)</span><br><span class="line">n3 = ListNode(<span class="number">5</span>)</span><br><span class="line">n4 = ListNode(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 构建节点之间的引用</span></span><br><span class="line">n0.<span class="built_in">next</span> = n1</span><br><span class="line">n1.<span class="built_in">next</span> = n2</span><br><span class="line">n2.<span class="built_in">next</span> = n3</span><br><span class="line">n3.<span class="built_in">next</span> = n4</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ul>
<li><p>在 n0 n1 之间插入节点:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">n0:ListNode,p:ListNode</span>):</span><br><span class="line">    n1 = n0.<span class="built_in">next</span>    <span class="comment">#保留一下被插入位置的后一个值</span></span><br><span class="line">    p.<span class="built_in">next</span> = n1     </span><br><span class="line">    n0.<span class="built_in">next</span> = p   </span><br></pre></td></tr></table></figure>

<blockquote>
<p>别忘了保存一下占据所插入位置的原来的元素</p>
</blockquote>
</li>
<li><p>插入头节点： 指向，更新头节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert_at_head</span>(<span class="params">head:ListNode,p :ListNode</span>) -&gt; ListNode:</span><br><span class="line">    p.<span class="built_in">next</span> = head</span><br><span class="line">    <span class="comment"># head = p  这里隐含一步 把头结点更改为 p</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>


</li>
<li><p>插入尾节点: 遍历找到尾节点，然后将当前尾节点指向真正的尾节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert_at_tail</span>(<span class="params">head:ListNode,p:ListNode</span>) -&gt; ListNode:</span><br><span class="line">    <span class="comment"># 如果头节点是空的，将p节点直接作为头节点</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> p </span><br><span class="line">    <span class="comment">#头节点非空，遍历找到尾节点</span></span><br><span class="line">    current = head</span><br><span class="line">    <span class="keyword">while</span> current.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span>  <span class="literal">None</span>:</span><br><span class="line">        current = current.<span class="built_in">next</span> </span><br><span class="line">    <span class="comment"># p.next = None   这一步是多余操作，因为新节点创建的时候默认的next 就是指向 None</span></span><br><span class="line">    current.<span class="built_in">next</span> = p</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><ul>
<li><p>删除中间节点 这里假设删除 n0 后的第一个节点 p ( n0 -&gt; p -&gt; n1)</p>
<p>只是更改指向</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">n0 : ListNode</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n0.<span class="built_in">next</span> :</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment">#先要找到后面两个节点 才能进行删除</span></span><br><span class="line">    p = n0.<span class="built_in">next</span></span><br><span class="line">    n1 = p.<span class="built_in">next</span></span><br><span class="line">    n0.<span class="built_in">next</span> = n1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果给定下标（index），删除指定索引的节点，我们应该通过遍历找到 下标index  前一个节点，以及这个节点，和它后一个节点。</p>
</blockquote>
</li>
<li><p>删除头节点  更新新的头节点即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_head</span>(<span class="params">head : ListNode</span>) -&gt; ListNode:</span><br><span class="line">    <span class="comment">#如果链表是空的，直接返回空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 非空，返回head的下一个节点</span></span><br><span class="line">    <span class="comment"># head(新) = head.next</span></span><br><span class="line">    <span class="keyword">return</span> head.<span class="built_in">next</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>后面也可以写成 head &#x3D; head.next   return head </p>
</blockquote>
</li>
<li><p>删除尾节点  需要遍历到倒数第二个节点，然后更新指向</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">removr_tail</span>(<span class="params">head : ListNode</span>) -&gt; ListNode:</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 为空，返回None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 只有一个值，删除完尾节点之后为空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head.<span class="built_in">next</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">    <span class="comment"># 循环找到倒数第二个节点，然后将其指针指向None</span></span><br><span class="line">    current = head</span><br><span class="line">    <span class="keyword">while</span> current.<span class="built_in">next</span>.<span class="built_in">next</span> :</span><br><span class="line">        current = current.<span class="built_in">next</span></span><br><span class="line">    current.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 当前current 为倒数第二个节点</span></span><br><span class="line">    <span class="keyword">return</span> head  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="访问操作"><a href="#访问操作" class="headerlink" title="访问操作"></a>访问操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">access</span>(<span class="params">head: ListNode, index: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">    code = head</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> code:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        code = code.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>用临时变量 code 避免对原来head 的修改。</p>
<p>下面会对head 进行修改</p>
<p>def access(head, index: int) :<br>    for _ in range(index):<br>        if not head:<br>            return None<br>        head &#x3D; head.next<br>    return head </p>
</blockquote>
<h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><p>返回该节点在链表中的索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">head : ListNode ,target : <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span> :</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 非空 的时候执行 当为none 的时候，全查找或者没有数值的时候直接返回-1 即可</span></span><br><span class="line">    <span class="keyword">while</span> head :</span><br><span class="line">        <span class="keyword">if</span> head.val == target :</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">        index +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>







<hr>
<h1 id="栈，队列"><a href="#栈，队列" class="headerlink" title="栈，队列"></a>栈，队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈的常用操作"><a href="#栈的常用操作" class="headerlink" title="栈的常用操作"></a>栈的常用操作</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">push()</td>
<td align="left">元素入栈，从顶部 o(1)</td>
</tr>
<tr>
<td align="left">pop()</td>
<td align="left">栈顶元素出栈（确保stack 不为空）o(1)</td>
</tr>
<tr>
<td align="left">peek()</td>
<td align="left">访问栈顶元素 o(1)</td>
</tr>
</tbody></table>
<h3 id="基于链表实现栈"><a href="#基于链表实现栈" class="headerlink" title="基于链表实现栈"></a>基于链表实现栈</h3><img src="D:\blog\lariblog\source\_posts\数据结构与算法\linkedlist_stack_step2_push.png" alt="linkedlist_stack_step2_push" style="zoom:50%;" />

<blockquote>
<p>push (val) : 将元素添加到有头节点的位置</p>
<p>pop(): 将头节点删除</p>
<p>使用链表的头节点作为栈顶</p>
<p>在pop(),与 push() 别忘了更新头节点</p>
</blockquote>
<ul>
<li><p>一些简单的初始化 </p>
<p>设置栈顶元素为头节点，以及栈的大小</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListStack</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>._peek : ListNode | <span class="literal">None</span> = <span class="literal">None</span> </span><br><span class="line">        <span class="variable language_">self</span>._size : <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._size == <span class="number">0</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
<li><p>push 函数实现  将元素插入到头节点的位置 ,指向+更新头节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,val</span>):</span><br><span class="line">    node = ListNode(val)  <span class="comment">#  node 自动指向 None</span></span><br><span class="line">    node.<span class="built_in">next</span> = <span class="variable language_">self</span>._peek</span><br><span class="line">    <span class="variable language_">self</span>._peek = node </span><br><span class="line">    <span class="variable language_">self</span>._size +=<span class="number">1</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
<li><p>pop （）   删除头节点 ，不指向，直接更新头节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">    num = <span class="variable language_">self</span>.peek()  <span class="comment"># 获取当前的栈顶元素</span></span><br><span class="line">    <span class="variable language_">self</span>._peek = <span class="variable language_">self</span>._peek.<span class="built_in">next</span></span><br><span class="line">    <span class="variable language_">self</span>._size -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>


</li>
<li><p>peek ()   头节点非空，返回节点的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 当头节点不是空的时候返回 值</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>._peek:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>._peek.val</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


</li>
<li><p>to_list () 转换成列表 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_list</span>(<span class="params">self</span>):</span><br><span class="line">   <span class="comment"># 1-&gt;2-&gt;3-&gt;4 -&gt;none</span></span><br><span class="line">    newlist = []</span><br><span class="line">    node = <span class="variable language_">self</span>._peek</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>._size):   <span class="comment"># 这里也可以用 while self._peek 来进行循环</span></span><br><span class="line">        newlist.append(node.val)</span><br><span class="line">        node = node.<span class="built_in">next</span> </span><br><span class="line">    <span class="keyword">return</span> newlist</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里引用 临时节点 node 避免对其破坏</p>
</blockquote>
</li>
</ul>
<h3 id="基于数组实现栈"><a href="#基于数组实现栈" class="headerlink" title="基于数组实现栈"></a>基于数组实现栈</h3><p>前缀表示法，后缀表示法，前传后 都是数字放栈，操作完入栈</p>
<p>中转后，操作符入栈，数字储存列表。</p>
<p>常见题型：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="comment"># Q1 在python 中设计 stack()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__items = []</span><br><span class="line"><span class="comment"># is_empty 用于检查是否为空，返回一个布尔值        </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.__items) == <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.__items)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,item</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__items.append(item)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__items.pop()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__items[-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#Q2 get_min 函数 </span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;我们要实现的功能</span></span><br><span class="line"><span class="string">push(x)  ——&gt; none ;push x on the stack</span></span><br><span class="line"><span class="string">top()  ——&gt; x   ; see the top element  and  return it </span></span><br><span class="line"><span class="string">pop()  ——&gt; x   ; 删除顶部元素并且返回该值</span></span><br><span class="line"><span class="string">get_min()  ——&gt; x ; 返回栈里最小的元素</span></span><br><span class="line"><span class="string">这里通过用两个栈,一个栈用于保持栈顶为最小的元素,另一个正常的进行栈的操作</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack = []</span><br><span class="line">        <span class="variable language_">self</span>.minstack = []</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack.append(x)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.minstack :</span><br><span class="line">            <span class="variable language_">self</span>.minstack.append(<span class="built_in">min</span>(x,<span class="variable language_">self</span>.minstack[-<span class="number">1</span>]))    </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.minstack.append(x)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.stack:</span><br><span class="line">            <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">            <span class="variable language_">self</span>.minstack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.stack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.minstack:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.minstack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Q3 关于符号</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;得到任何类型的打开括号就将其放入栈中，然后检测到闭合括号，通过弹出栈顶元素查看是否匹配</span></span><br><span class="line"><span class="string">if open : add</span></span><br><span class="line"><span class="string">else : check</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self,s:<span class="built_in">str</span></span>)-&gt; <span class="built_in">bool</span> :     <span class="comment"># 进行注解 </span></span><br><span class="line">        stack = []</span><br><span class="line">        </span><br><span class="line">        mapping = &#123;</span><br><span class="line">            <span class="string">&quot;&#123;&quot;</span>:<span class="string">&quot;&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;(&quot;</span>:<span class="string">&quot;)&quot;</span>,</span><br><span class="line">            <span class="string">&quot;[&quot;</span>:<span class="string">&quot;]&quot;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s :</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> <span class="string">&quot;(&#123;[&quot;</span>:</span><br><span class="line">                stack.append(char)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    <span class="keyword">if</span> char == mapping.get(stack[-<span class="number">1</span>]):</span><br><span class="line">                        stack.pop()</span><br><span class="line">                    <span class="keyword">return</span>  <span class="literal">False</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>   <span class="comment"># 如果只有闭合括号没有开括号也返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>    <span class="comment"># 当检查完所有的闭合括号，看栈里是否还有剩余</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Q4 按照software 讲解的过程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">validate_braces</span>(<span class="params">input_str</span>):</span><br><span class="line">    stack = Stack()</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> input_str:</span><br><span class="line">        <span class="keyword">if</span> char== <span class="string">&quot;&#123;&quot;</span>:</span><br><span class="line">            stack.push(char)</span><br><span class="line">        <span class="keyword">elif</span> char == <span class="string">&quot;&#125;&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> stack.pop() != <span class="string">&quot;&#123;&quot;</span> <span class="keyword">or</span> stack.is_empty():</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> stack.is_empty():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;correct&quot;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算机计算方法  infix -&gt; 中缀转化成后缀</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self,s:<span class="built_in">str</span></span>)-&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">s</span>):</span><br><span class="line">            infix = []</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">infix_to_postfix</span>(<span class="params">infix</span>):</span><br><span class="line">            postfix = []</span><br><span class="line">            stack = []</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> infix :</span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    stack.append(i)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                    <span class="keyword">while</span> stack[-<span class="number">1</span>]!= <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                        postfix.append(stack.pop())</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">elif</span> i <span class="keyword">not</span> <span class="keyword">in</span> operators:</span><br><span class="line">                    postfix.append(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">while</span> stack <span class="keyword">and</span> priority[stack[-<span class="number">1</span>]] &gt;= priority[i]:</span><br><span class="line">                        postfix.append(stack.pop())</span><br><span class="line">                    stack.append(i)</span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                postfix.append(stack.pop())</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> postfix </span><br><span class="line">        <span class="keyword">import</span> operator</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">evaluate_postfix</span>(<span class="params">postfix</span>):</span><br><span class="line">            stack = []</span><br><span class="line">            ops = &#123;</span><br><span class="line">                <span class="string">&quot;+&quot;</span> : operator.add,</span><br><span class="line">                <span class="string">&quot;-&quot;</span> : operator.sub,</span><br><span class="line">                <span class="string">&quot;*&quot;</span> : operator.mul,</span><br><span class="line">                <span class="string">&quot;/&quot;</span> : operator.truediv</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> postfix :</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> ops :</span><br><span class="line">                    stack.append(<span class="built_in">int</span>(i))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    n1 = stack.pop()</span><br><span class="line">                    n2 = stack.pop()</span><br><span class="line">                    result = ops[i](n1,n2)</span><br><span class="line">                    stack.append(<span class="built_in">int</span>(result))</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        operators = <span class="string">&quot;()+-*/&quot;</span></span><br><span class="line">        priority = &#123;</span><br><span class="line">            <span class="string">&quot;(&quot;</span> : -<span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;*&quot;</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;/&quot;</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;+ &quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;-&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>我们将队列头部称为“队首”，尾部称为“队尾”，将把元素加入队尾的操作称为“入队”，删除队首元素的操作称为“出队”。</p>
<img src="D:\blog\lariblog\source\_posts\数据结构与算法\queue_operations.png" alt="queue_operations" style="zoom:50%;" />



<p>队列常用操作与栈类似，只不过push 是入队，将元素添加至队尾</p>
<p>我们可以直接使用python 中的队列类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化队列</span></span><br><span class="line"><span class="comment">#在 Python 中，我们一般将双向队列类 deque 当作队列使用</span></span><br><span class="line"><span class="comment">#虽然 queue.Queue() 是纯正的队列类，但不太好用，因此不推荐</span></span><br><span class="line">que: deque[<span class="built_in">int</span>] = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment">#元素入队</span></span><br><span class="line">que.append(<span class="number">1</span>)</span><br><span class="line">que.append(<span class="number">3</span>)</span><br><span class="line">que.append(<span class="number">2</span>)</span><br><span class="line">que.append(<span class="number">5</span>)</span><br><span class="line">que.append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#访问队首元素</span></span><br><span class="line">front: <span class="built_in">int</span> = que[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#元素出队</span></span><br><span class="line">pop: <span class="built_in">int</span> = que.popleft()</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取队列的长度</span></span><br><span class="line">size: <span class="built_in">int</span> = <span class="built_in">len</span>(que)</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断队列是否为空</span></span><br><span class="line">is_empty: <span class="built_in">bool</span> = <span class="built_in">len</span>(que) == <span class="number">0</span></span><br></pre></td></tr></table></figure>









<h3 id="基于链表实现队列"><a href="#基于链表实现队列" class="headerlink" title="基于链表实现队列"></a>基于链表实现队列</h3><img src="D:\blog\lariblog\source\_posts\数据结构与算法\linkedlist_queue_step2_push.png" alt="linkedlist_queue_step2_push" style="zoom:50%;" />





<p>入队 ： 将节点添加到链表尾部 。</p>
<p>出队： 链表头部删除操作</p>
<ul>
<li><p>初始化操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListQueue</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>._front  = <span class="literal">None</span>   <span class="comment"># 初始化头节点front</span></span><br><span class="line">        <span class="variable language_">self</span>._rear = <span class="literal">None</span>  <span class="comment"># 初始化尾节点 rear</span></span><br><span class="line">        <span class="variable language_">self</span>._size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._size</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._size == <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里初始化了头节点和尾节点！</p>
</blockquote>
</li>
<li><p>push()  把节点添加到链表尾部</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,num</span>):</span><br><span class="line">    node = ListNode(num)</span><br><span class="line">    <span class="comment">#如果链表是空的 将头节点尾节点都指向 node</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>._front <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">        <span class="variable language_">self</span>._front = node</span><br><span class="line">        <span class="variable language_">self</span>._rear = node </span><br><span class="line">    <span class="comment"># 非空，将尾节点指向，更新尾节点</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="variable language_">self</span>._rear.<span class="built_in">next</span> = node</span><br><span class="line">        <span class="variable language_">self</span>._rear = node </span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">self</span>._size += <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>pop()  删除头节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 先要获取一下当前头节点的值 </span></span><br><span class="line">    num = <span class="variable language_">self</span>.peek()</span><br><span class="line">    <span class="variable language_">self</span>._front = <span class="variable language_">self</span>._front.<span class="built_in">next</span> </span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">self</span>._size -=<span class="number">1</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>peek()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">        <span class="keyword">raise</span> IndexError (<span class="string">&quot;队列为空&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>._front.val </span><br><span class="line">	</span><br><span class="line">  </span><br></pre></td></tr></table></figure>


</li>
<li><p>to_list()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_list</span>(<span class="params">self</span>):</span><br><span class="line">    queue = []</span><br><span class="line">    node = <span class="variable language_">self</span>._front </span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        queue.append(node.val)</span><br><span class="line">        node = node.<span class="built_in">next</span> </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> queue</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基于数组实现队列"><a href="#基于数组实现队列" class="headerlink" title="基于数组实现队列"></a>基于数组实现队列</h3><p>我们可以使用一个变量 <code>front</code> 指向队首元素的索引，并维护一个变量 <code>size</code> 用于记录队列长度。定义 <code>rear = front + size</code> ，这个公式计算出的 <code>rear</code> 指向队尾元素之后的<strong>下一个位置</strong>。</p>
<blockquote>
<p>数组中的下标为<code>[0,capacity-1]</code>  比如说，这个队列（环形数组为<code>[none,2,4,5,none]</code>） front 指向的是队首元素 2  rear 指向的是 最后面的 none .</p>
</blockquote>
<p>基于此设计，<strong>数组中包含元素的有效区间为 <code>[front, rear - 1]</code></strong></p>
<ul>
<li>入队操作：将输入元素赋值给 <code>rear</code> 索引处，并将 <code>size</code> 增加 1 。</li>
<li>出队操作：只需将 <code>front</code> 增加 1 ，并将 <code>size</code> 减少 1 。</li>
</ul>
<p>在不断的入队与出队，我们是将front , rear 分别往下移动来实现的，所以<strong>当它们到达数组尾部时就无法继续移动了</strong>。为了解决此问题，我们可以将数组视为首尾相接的“环形数组”。</p>
<p>对于环形数组，我们需要让 <code>front</code> 或 <code>rear</code> 在越过数组尾部时，直接回到数组头部继续遍历。这种周期性规律可以通过“取余操作”</p>
<ul>
<li><p>初始化 。队列的容量，队列的长度，以及队首指针</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,size</span>):</span><br><span class="line">        <span class="variable language_">self</span>._nums = [<span class="number">0</span>]*size   <span class="comment">#用于储存队列元素的数组</span></span><br><span class="line">        <span class="variable language_">self</span>._front = <span class="number">0</span>  <span class="comment">#队首指针</span></span><br><span class="line">        <span class="variable language_">self</span>._size = <span class="number">0</span> <span class="comment"># 队列长度</span></span><br><span class="line">    <span class="comment">#获取队列的容量    </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">capacity</span> (<span class="variable language_">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._nums)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span> (<span class="variable language_">self</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._size == <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>push()    计算尾指针rear  ;  将元素添加到rear 处； 将 size 自增 1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;循环计算出现有队列的末尾需要插入的位置rear&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果队列已将满，不能再进行插入操作</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>._size == <span class="variable language_">self</span>.capacity :</span><br><span class="line">        <span class="keyword">raise</span> IndexError (<span class="string">&quot;队列已满&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    rear = (<span class="variable language_">self</span>._front + <span class="variable language_">self</span>._size)% <span class="variable language_">self</span>.capacity</span><br><span class="line">    <span class="variable language_">self</span>._nums [rear] = num</span><br><span class="line">    <span class="variable language_">self</span>._size +=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
<li><p>pop()  将对首指针 front 自增1  size 自减1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">    num = <span class="variable language_">self</span>.peek()</span><br><span class="line">    <span class="variable language_">self</span>._front = (<span class="variable language_">self</span>._front + <span class="number">1</span>) % <span class="variable language_">self</span>.capacity</span><br><span class="line">    <span class="variable language_">self</span>._size -=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
<li><p>peek ()   非空就输出值</p>
</li>
</ul>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 如果对列是空的，返回 none</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty:</span><br><span class="line">        <span class="keyword">return</span> IndexError (<span class="string">&quot;队列为空&quot;</span>)</span><br><span class="line">    num = <span class="variable language_">self</span>._nums[<span class="variable language_">self</span>._front]</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<ul>
<li><p>to_list </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_list</span>(<span class="params">self</span>):</span><br><span class="line">    res = [<span class="number">0</span>]* <span class="variable language_">self</span>._size </span><br><span class="line">    i = <span class="variable language_">self</span>._front</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>._size):</span><br><span class="line">        res[j] = <span class="variable language_">self</span>._nums[i%<span class="variable language_">self</span>.capacity]</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里仍然用一个临时变量作为队伍首节点</p>
</blockquote>
</li>
</ul>
<h4 id="另外一种写法"><a href="#另外一种写法" class="headerlink" title="另外一种写法"></a>另外一种写法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化循环队列&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.capacity = capacity</span><br><span class="line">        <span class="variable language_">self</span>.items = [<span class="literal">None</span>] * capacity  <span class="comment"># 固定大小的数组</span></span><br><span class="line">        <span class="variable language_">self</span>.front = <span class="number">0</span>  <span class="comment"># 队首指针</span></span><br><span class="line">        <span class="variable language_">self</span>.rear = <span class="number">0</span>   <span class="comment"># 队尾指针</span></span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span>   <span class="comment"># 队列中元素的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查队列是否为空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_full</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查队列是否已满&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size == <span class="variable language_">self</span>.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;入队操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_full():</span><br><span class="line">            <span class="keyword">raise</span> OverflowError(<span class="string">&quot;队列已满&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.items[<span class="variable language_">self</span>.rear] = item               <span class="comment"># 在 rear 指针位置插入元素</span></span><br><span class="line">        <span class="variable language_">self</span>.rear = (<span class="variable language_">self</span>.rear + <span class="number">1</span>) % <span class="variable language_">self</span>.capacity  <span class="comment"># 更新 rear 指针</span></span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;出队操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;队列为空&quot;</span>)</span><br><span class="line">        item = <span class="variable language_">self</span>.items[<span class="variable language_">self</span>.front]             <span class="comment"># 取出 front 指针位置的元素</span></span><br><span class="line">        <span class="variable language_">self</span>.items[<span class="variable language_">self</span>.front] = <span class="literal">None</span>             <span class="comment"># 清空当前位置</span></span><br><span class="line">        <span class="variable language_">self</span>.front = (<span class="variable language_">self</span>.front + <span class="number">1</span>) % <span class="variable language_">self</span>.capacity  <span class="comment"># 更新 front 指针</span></span><br><span class="line">        <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查看队首元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;队列为空&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.items[<span class="variable language_">self</span>.front]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取队列中的元素数量&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_list</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回当前队列的列表表示，方便查看内容&quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        idx = <span class="variable language_">self</span>.front</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.size):</span><br><span class="line">            result.append(<span class="variable language_">self</span>.items[idx])</span><br><span class="line">            idx = (idx + <span class="number">1</span>) % <span class="variable language_">self</span>.capacity</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在环形队列的固定队首方案中，推荐使用 <code>rear = (self._front + self._size) % self.capacity()</code>，而在动态指针移动的队列方案中，可用 <code>rear = (rear + 1) % capacity</code>。</p>
</blockquote>
<h2 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h2><img src="D:\blog\lariblog\source\_posts\数据结构与算法\双向队列(1).png" alt="双向队列(1)" style="zoom:50%;" />



<h3 id="双向列表的常用操作"><a href="#双向列表的常用操作" class="headerlink" title="双向列表的常用操作"></a>双向列表的常用操作</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>push_first()</code></td>
<td>将元素添加至队首</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>push_last()</code></td>
<td>将元素添加至队尾</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>pop_first()</code></td>
<td>删除队首元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>pop_last()</code></td>
<td>删除队尾元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>peek_first()</code></td>
<td>访问队首元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>peek_last()</code></td>
<td>访问队尾元素</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>在python 中可以直接用内置的类实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化双向队列</span></span><br><span class="line">deq: deque[<span class="built_in">int</span>] = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素入队</span></span><br><span class="line">deq.append(<span class="number">2</span>)      <span class="comment"># 添加至队尾</span></span><br><span class="line">deq.append(<span class="number">5</span>)</span><br><span class="line">deq.append(<span class="number">4</span>)</span><br><span class="line">deq.appendleft(<span class="number">3</span>)  <span class="comment"># 添加至队首</span></span><br><span class="line">deq.appendleft(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素</span></span><br><span class="line">front: <span class="built_in">int</span> = deq[<span class="number">0</span>]  <span class="comment"># 队首元素</span></span><br><span class="line">rear: <span class="built_in">int</span> = deq[-<span class="number">1</span>]  <span class="comment"># 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素出队</span></span><br><span class="line">pop_front: <span class="built_in">int</span> = deq.popleft()  <span class="comment"># 队首元素出队</span></span><br><span class="line">pop_rear: <span class="built_in">int</span> = deq.pop()       <span class="comment"># 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取双向队列的长度</span></span><br><span class="line">size: <span class="built_in">int</span> = <span class="built_in">len</span>(deq)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断双向队列是否为空</span></span><br><span class="line">is_empty: <span class="built_in">bool</span> = <span class="built_in">len</span>(deq) == <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="基于双向链表实现双向队列"><a href="#基于双向链表实现双向队列" class="headerlink" title="基于双向链表实现双向队列"></a>基于双向链表实现双向队列</h3><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>又称散列表，实现key 与 vvalue 的映射，实现高效元素查询。<strong>在哈希表中进行增删查改的时间复杂度都是 O(1)</strong> ，非常高效</p>
<h2 id="哈希表常用操作"><a href="#哈希表常用操作" class="headerlink" title="哈希表常用操作"></a>哈希表常用操作</h2><p>在python 中，哈希表就是我们所说的字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#初始化</span></span><br><span class="line">hmap = &#123;&#125;</span><br><span class="line"><span class="comment">#增加</span></span><br><span class="line">hmap[<span class="number">1234</span>] = <span class="string">&quot;jdskal&quot;</span></span><br><span class="line">hmap[<span class="number">4324</span>] = <span class="string">&quot;jlfksdd&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">hmap.pop(<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找</span></span><br><span class="line">name =hmap[<span class="number">4324</span>]</span><br></pre></td></tr></table></figure>

<p>哈希表有三种遍历的方法： 遍历键值对，遍历值，遍历键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#键值对</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> hmap.items():</span><br><span class="line">    <span class="built_in">print</span>(key,<span class="string">&quot;-&gt;&quot;</span>,value)</span><br><span class="line"><span class="comment">#键</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> hmap.keys():</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"><span class="comment">#值</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> hmap.values():</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="哈希表的简单实现"><a href="#哈希表的简单实现" class="headerlink" title="哈希表的简单实现"></a>哈希表的简单实现</h2><blockquote>
<p>什么是哈希函数？</p>
<p>哈希函数就是将输入的 键 映射为数组中的索引值 </p>
</blockquote>
<p>我们将数组中的每个空位置看成桶 ——包含key 和value </p>
<p>为了将数据（通常是键值对）存储到哈希表中，我们先计算该数据对应的“桶”的位置（索引），这就是哈希函数的作用。</p>
<p>通过这个索引，直接访问数组中的位置并存储或检索数据，这样可以做到<strong>常数时间复杂度</strong> <code>O(1)</code>。</p>
<p>哈希函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hash_function</span>(<span class="params">key, capacity</span>):</span><br><span class="line">    <span class="comment"># 将 key 转换为整数（这里假设 key 是字符串），并取模数组的大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>(key) % capacity</span><br><span class="line"> </span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>哈希冲突，就是多个key 指向同一个储存位置的时候，为了让避免哈希冲突，通过阔容哈希表来实现。</p>
</blockquote>
<p>另一种方法：中平方哈希方法是一种针对数字键的替代哈希技术</p>
<p>将数值平方，去平方的部分数字，将其进行取模运算。</p>
<blockquote>
<p>对于字符串，我们用ascll 码获得数字总和，然后获得索引，那么如果出现两个单词的字母完全相同那么会对用相同的索引，所以通过每个字符乘以权重在进行相加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hash_string</span>(<span class="params">s,stringsize</span>):</span><br><span class="line">    <span class="built_in">sum</span> =<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span>+(pos+<span class="number">1</span>)*<span class="built_in">ord</span>(s[pos])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>%stringsize</span><br></pre></td></tr></table></figure>

<p>pos +1  是为了权重不为零</p>
</blockquote>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>为了提升效率，我们可以采用以下策略。</p>
<ol>
<li>改良哈希表数据结构，<strong>使得哈希表可以在出现哈希冲突时正常工作</strong>。</li>
<li>仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。</li>
</ol>
<p>哈希表的结构改良方法主要包括“链式地址”和“开放寻址”</p>
<p>链式地址 ： 将单个元素转化成链表，将发生冲突的键值对储存在同一个链表中。</p>
<p>开放寻址：有三种方法，线性侦测，平方探测，多次哈希</p>
<h3 id="线性侦测"><a href="#线性侦测" class="headerlink" title="线性侦测"></a>线性侦测</h3><ul>
<li><p>插入元素：先通过哈希函数计算出索引，如果索引中有元素，就以步长为1 向后线性遍历，(这里也有可能是步长的平方)直到找到空元素，将其插入。</p>
</li>
<li><p>寻找元素：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 <code>value</code> 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 <code>None</code></p>
</li>
<li><p>删除元素：不能直接进行删除操作，会对后续查找元素造成影响。</p>
<p>一般使用<code>TOMBSTONE</code>进行标记</p>
<blockquote>
<p><strong>懒删除可能会加速哈希表的性能退化</strong>。这是因为每次删除操作都会产生一个删除标记，随着 <code>TOMBSTONE</code> 的增加，搜索时间也会增加，因为线性探测可能需要跳过多个 <code>TOMBSTONE</code> 才能找到目标元素。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#线性探测    </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_new_hash_code_probing</span>(<span class="params">self,index</span>):</span><br><span class="line">        <span class="keyword">return</span> (index+<span class="number">1</span>)%<span class="variable language_">self</span>.__size	</span><br><span class="line"><span class="comment">#二次探测</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_new_hash_code_quadratic_probing</span>(<span class="params">self, index, distance</span>):</span><br><span class="line">        <span class="keyword">return</span> (index + distance**<span class="number">2</span>)%<span class="variable language_">self</span>.__size    </span><br><span class="line"><span class="comment">#双重哈希探测</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_new_hash_code_double_hashing</span>(<span class="params">self,key</span>):</span><br><span class="line">        index = <span class="variable language_">self</span>.get_hash_code(key)</span><br><span class="line">        <span class="keyword">return</span> (index+(<span class="variable language_">self</span>.__second_hash_value - (key%<span class="variable language_">self</span>.__second_hash_value)))%<span class="variable language_">self</span>.__size</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是一种非线性的数据结构（分治逻辑）与链表相似，二叉树的基本单元是节点，每个节点包含<strong>值，左子节点引用和右子节点</strong>引用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.left : TreeNode= <span class="literal">None</span>  <span class="comment">#定义左节点引用</span></span><br><span class="line">        <span class="variable language_">self</span>.right : TreeNode = <span class="literal">None</span> <span class="comment">#定义右节点引用                </span></span><br><span class="line"><span class="comment">#另一种方法        </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val,left=<span class="literal">None</span>,right=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.left = left</span><br><span class="line">        <span class="variable language_">self</span>.right = right</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个节点都有两个指针，指向<strong>左子节点</strong>和<strong>右子节点</strong>，该节点被称之为左子节点和右子节点的<strong>父节点</strong>。当给定一个二叉树的节点之后，我们将该节点的左子节点以及下面的节点形成的树称之为<strong>左子树</strong></p>
</blockquote>
<blockquote>
<img src="D:\blog\lariblog\source\_posts\数据结构与算法\binary_tree_definition.png" style="zoom:50%;" />
</blockquote>
<h3 id="二叉树的一些概念"><a href="#二叉树的一些概念" class="headerlink" title="二叉树的一些概念"></a>二叉树的一些概念</h3><ul>
<li><p>根节点 ： 位于二叉树的顶层，没有父节点</p>
</li>
<li><p>叶节点 ： 没有子节点的节点，两个指针指向None</p>
</li>
<li><p>边 ： 连接两个节点的线段，即节点引用（指针）</p>
</li>
<li><p>节点所在的层：递增，根节点的层数为1</p>
</li>
<li><p>节点的度： 节点的子节点的数量。 在二叉树中，度的取值范围为0，1，2</p>
</li>
<li><p>二叉树的高度： 从根节点到最远叶节点所经过的边的数量</p>
</li>
<li><p>节点的深度：从该根节点到该节点所经过的边的个数</p>
</li>
<li><p>节点的高度： 从距离该节点最远的叶节点到该节点做经过的边的数量</p>
</li>
</ul>
<blockquote>
<p>请注意，我们通常将“高度”和“深度”定义为“经过的边的数量”，但有些题目或教材可能会将其定义为“经过的节点的数量”。在这种情况下，高度和深度都需要加 1 。</p>
</blockquote>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li><p>插入与删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#初始化二叉树</span></span><br><span class="line"><span class="comment">#初始化节点</span></span><br><span class="line">n1 = TreeNode(val=<span class="number">1</span>)</span><br><span class="line">n2 = TreeNode(val=<span class="number">2</span>)</span><br><span class="line">n3 = TreeNode(val=<span class="number">3</span>)</span><br><span class="line">n4 = TreeNode(val=<span class="number">4</span>)</span><br><span class="line">n5 = TreeNode(val=<span class="number">5</span>)</span><br><span class="line"><span class="comment">#构建节点之间的引用（指针）</span></span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line">n2.left = n4</span><br><span class="line">n2.right = n5      </span><br><span class="line">      </span><br><span class="line"><span class="comment">#插入与删除</span></span><br><span class="line">p = TreeNode(<span class="number">0</span>)</span><br><span class="line">n1.left = p</span><br><span class="line">p.left = n2  <span class="comment">#在n1 与n2 之间插入节点p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除节点p</span></span><br><span class="line">n1.left = n2</span><br><span class="line"></span><br><span class="line"><span class="comment">#另外一种方法，在类中创建方法</span></span><br></pre></td></tr></table></figure>

<p>学校版本</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val,left=<span class="literal">None</span>,right=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.left = left</span><br><span class="line">        <span class="variable language_">self</span>.right = right</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_left</span>(<span class="params">self,newval</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.left== <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.left = TreeNode(newval)    </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            subtree = TreeNode(newval,left = <span class="variable language_">self</span>.left) <span class="comment">#生成子树</span></span><br><span class="line">            <span class="variable language_">self</span>.left = subtree <span class="comment">#把子树作为整体添加进去  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_right</span>(<span class="params">self,newval</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.right = TreeNode(newval)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            subtree = TreeNode(newval,right = <span class="variable language_">self</span>.right)</span><br><span class="line">            <span class="variable language_">self</span>.right = subtree</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_left</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.left</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_right</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.right</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_val</span>(<span class="params">self,val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_val</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.val</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h3 id="常见二叉树类型"><a href="#常见二叉树类型" class="headerlink" title="常见二叉树类型"></a>常见二叉树类型</h3><ul>
<li><p>完美二叉树(满二叉树)</p>
<p>叶节点的度为0，其余所有节点的度都为2，如果树的高度是h，则节点总数为<code>2^&#123;h+1&#125; -1</code> </p>
<p><img src="D:\blog\lariblog\source\_posts\数据结构与算法\perfect_binary_tree.png" style="zoom:50%;" />完美二叉树</p>
</li>
<li><p>完全二叉树</p>
<p>只有最底层的节点未被填满，且最底层节点尽量靠左填充。请注意，完美二叉树也是一棵完全二叉树。</p>
<p><img src="D:\blog\lariblog\source_posts\数据结构与算法\complete_binary_tree.png"></p>
</li>
<li><p>完满二叉树</p>
<p>除了叶节点之外，其余所有节点都有两个子节点。</p>
<img src="D:\blog\lariblog\source\_posts\数据结构与算法\full_binary_tree.png" style="zoom:50%;" />
</li>
<li><p>平衡二叉树</p>
<p>任何节点的左子树和右子树的高度之差的绝对值不超过1</p>
<img src="D:\blog\lariblog\source\_posts\数据结构与算法\balanced_binary_tree.png" style="zoom:50%;" /></li>
</ul>
<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p>二叉树是一种非线性的数据结构，所以遍历树一般要用到搜素算法</p>
<p>常见遍历方式： 层序遍历，前序遍历，中序遍历和后序遍历</p>
<ul>
<li><p>层序遍历 </p>
<p>从顶部到底部逐层遍历二叉树，每一层按照从左到右的顺序遍历访问节点 本质上是 <strong>广度优先遍历</strong> 也是<strong>广度优先搜索</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level_order</span>(<span class="params">root</span>):</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    </span><br><span class="line">    result = []</span><br><span class="line">    <span class="comment">#队列非空就左端弹出，将值储存在列表中</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        result.append(node.val)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#如果该节点有左子右子，则入队</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span>  <span class="literal">None</span>:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<blockquote>
<img src="D:\blog\lariblog\source\_posts\数据结构与算法\binary_tree_bfs.png" style="zoom:50%;" />
</blockquote>
</li>
<li><p>前序遍历，中序，后序遍历</p>
<p>前序遍历： 根节点——&gt; 左子树——&gt; 右子树</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#递归实现前序遍   </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preorder_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> [root.val]+ preorder_traversal(root.left)+preorder_traversal(root.right)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preorder_traversal_iterative</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment">#栈是用来存储东西的，先进后出，所以把根存入之后取出来，存有右节点，存左节点</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        result.append(node.val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.right :</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>中序遍历： 左子树——&gt; 根节点——&gt; 右子树 </p>
<p>左子树 -&gt; 当前节点 -&gt; 右子树</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder_traversal</span>(<span class="params">root</span>):  </span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> inorder_traversal(root.left)+[root.val]+inorder_traversal(root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inorder_traversal_iterative</span>(<span class="params">root</span>):</span><br><span class="line">    </span><br><span class="line">    result=[]   <span class="comment">#记录结果</span></span><br><span class="line">    stack = []   <span class="comment">#模拟递归的栈</span></span><br><span class="line">    current = root      <span class="comment">#当前节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#栈不为空或者当前节点存在</span></span><br><span class="line">    <span class="keyword">while</span> current <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="comment">#1.先将左子树入栈</span></span><br><span class="line">        <span class="keyword">while</span> current :</span><br><span class="line">            stack.append(current)</span><br><span class="line">            current = current.left</span><br><span class="line">            </span><br><span class="line">        <span class="comment">#弹出栈顶节点，并访问</span></span><br><span class="line">        current = stack.pop()</span><br><span class="line">        result.append(current.val)</span><br><span class="line">        <span class="comment">#访问右子树</span></span><br><span class="line">        current = current.right    </span><br><span class="line">    <span class="keyword">return</span> result      </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>后序遍历： 左子树——&gt;右子树——&gt; 根节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorder_traversal</span>(<span class="params">root</span>): </span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> postorder_traversal(root.left)+postorder_traversal(root.right) + [root.val]       </span><br><span class="line">     </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postorder_traversal_iterative</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    stack = [root]</span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack :</span><br><span class="line">        node = stack.pop() </span><br><span class="line">        result.append(node.val)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.left :</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<blockquote>
<img src="D:\blog\lariblog\source\_posts\数据结构与算法\binary_tree_dfs.png" style="zoom:50%;" />

</blockquote>
</li>
</ul>
<h3 id="前序遍历和后序遍历的区别"><a href="#前序遍历和后序遍历的区别" class="headerlink" title="前序遍历和后序遍历的区别"></a>前序遍历和后序遍历的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>前序遍历</th>
<th>后序遍历</th>
</tr>
</thead>
<tbody><tr>
<td><strong>遍历顺序</strong></td>
<td>当前节点 -&gt; 左子树 -&gt; 右子树</td>
<td>左子树 -&gt; 右子树 -&gt; 当前节点</td>
</tr>
<tr>
<td><strong>栈的入栈顺序</strong></td>
<td>右子树先入栈，左子树后入栈</td>
<td>左子树先入栈，右子树后入栈</td>
</tr>
<tr>
<td>结果反转</td>
<td>不需要反转</td>
<td>需要反转结果，因为是先右后左入栈</td>
</tr>
<tr>
<td>访问顺序</td>
<td>访问根节点后先访问左子树，再访问右子树</td>
<td>访问左右子树后再访问根节点</td>
</tr>
</tbody></table>
<h2 id="二叉树的数组表示"><a href="#二叉树的数组表示" class="headerlink" title="二叉树的数组表示"></a>二叉树的数组表示</h2><h3 id="表示完美二叉树"><a href="#表示完美二叉树" class="headerlink" title="表示完美二叉树"></a>表示完美二叉树</h3><p>依照层序遍历，我们可以推导出父节点与子节点之间的关系：<strong>当前节点为 i ，左子节点为 2i +1 右子节点为 2i +2</strong></p>
<h3 id="表示任意的二叉树"><a href="#表示任意的二叉树" class="headerlink" title="表示任意的二叉树"></a>表示任意的二叉树</h3><p>在二叉树的中间层通常存在许多 <code>None</code> 。由于层序遍历序列并不包含这些 <code>None</code> ，因此我们无法仅凭该序列来推测 <code>None</code> 的数量和分布位置。<strong>存在多种二叉树结构都符合该层序遍历序列</strong></p>
<p><strong>考虑在层序遍历序列中显式地写出所有 <code>None</code></strong></p>
<p>如图：<img src="D:\blog\lariblog\source\_posts\数据结构与算法\array_representation_with_empty.png" style="zoom:50%;" /></p>
<p>回顾完全二叉树的定义，<code>None</code> 只出现在最底层且靠右的位置，<strong>因此所有 <code>None</code> 一定出现在层序遍历序列的末尾</strong>。</p>
<p>这意味着使用数组表示完全二叉树时，可以省略存储所有 <code>None</code></p>
<p>如图：</p>
<img src="D:\blog\lariblog\source\_posts\数据结构与算法\array_representation_complete_binary_tree.png" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;1.给定某节点,获取它的值,左右子节点,父节点</span></span><br><span class="line"><span class="string">   2.获取前序中序后序层序 序列的结果&quot;&quot;&quot;</span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;数组表示下的二叉树类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,arr</span>):</span><br><span class="line">        <span class="variable language_">self</span>._tree = <span class="built_in">list</span>(arr)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._tree)</span><br><span class="line">    <span class="comment">#获取索引为i的元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">val</span>(<span class="params">self,i</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="variable language_">self</span>.size():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._tree[i]</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#获取索引为i的左子节点的索引</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">left</span>(<span class="params">self,i</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">    <span class="comment">#获取索引为i的右子节点的索引</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">right</span>(<span class="params">self,i</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">self,i</span>):</span><br><span class="line">        <span class="keyword">return</span> (i-<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#层序遍历：</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">level_order</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.size()):</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.val(i) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.val(i)) </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br><span class="line">       </span><br><span class="line">    <span class="comment">#深度优先遍历</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;i代表当前节点的索引,order代表遍历的顺,这里注意右子树的访问试下左子树递归完成之后自然发生的&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,i,order</span>):</span><br><span class="line">        <span class="comment">#递归中止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.val(i) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment">#前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> order == <span class="string">&quot;pre&quot;</span>:</span><br><span class="line">            <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.val(i))</span><br><span class="line">        <span class="variable language_">self</span>.dfs(<span class="variable language_">self</span>,<span class="variable language_">self</span>.left(i),order) <span class="comment">#在递归访问左右子树之前,先访问根节点，而后递归访问左子树</span></span><br><span class="line">        <span class="comment">#中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> order == <span class="string">&quot;in&quot;</span>:</span><br><span class="line">            <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.val(i))</span><br><span class="line">        <span class="variable language_">self</span>.dfs(<span class="variable language_">self</span>,<span class="variable language_">self</span>.right(i),order) <span class="comment">#在递归访问左子树之后、右子树之前将当前节点加入,而后递归访问右子树</span></span><br><span class="line">        <span class="comment">#后序遍历</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> order == <span class="string">&quot;post&quot;</span>:</span><br><span class="line">            <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.val(i))   <span class="comment">#在递归访问左右子树之后将当前节点加入结果。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pre_order</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.dfs(<span class="number">0</span>,<span class="string">&quot;pre&quot;</span>)              </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">in_order</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.dfs(<span class="number">0</span>,<span class="string">&quot;in&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post_order</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.dfs(<span class="number">0</span>,<span class="string">&quot;post&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br><span class="line">        </span><br></pre></td></tr></table></figure>







<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p><strong>二叉搜索树满足以下条件</strong></p>
<ul>
<li>对于根节点，左子树的所有节点的值 &lt; 根节点的值 &lt;右子树的所有节点的值</li>
<li>任意节点的左右子树也是二叉搜索树，即同样满足上述条件</li>
</ul>
<h3 id="二叉树的操作"><a href="#二叉树的操作" class="headerlink" title="二叉树的操作"></a>二叉树的操作</h3><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><p>与二分查找的原理类似</p>
<p>给定目标节点值 <code>num</code> ，可以根据二叉搜索树的性质来查找。如图 7-17 所示，我们声明一个节点 <code>cur</code> ，从二叉树的根节点 <code>root</code> 出发，循环比较节点值 <code>cur.val</code> 和 <code>num</code> 之间的大小关系。</p>
<p>若 <code>cur.val &lt; num</code> ，说明目标节点在 <code>cur</code> 的右子树中，因此执行 <code>cur = cur.right</code> 。</p>
<p>若 <code>cur.val &gt; num</code> ，说明目标节点在 <code>cur</code> 的左子树中，因此执行 <code>cur = cur.left</code> 。</p>
<p>若 <code>cur.val = num</code> ，说明找到目标节点，跳出循环并返回该节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,num</span>):</span><br><span class="line">    cur = <span class="variable language_">self</span>._root</span><br><span class="line">    <span class="keyword">while</span> cur : <span class="comment">#直到越过叶子节点时候跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> cur.val &lt; num:</span><br><span class="line">            cur = cur.right</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">elif</span> cur.val &gt; num:</span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span> </span><br><span class="line">    <span class="keyword">return</span> cur   </span><br></pre></td></tr></table></figure>



<h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><p>寻找节点插入位置，在该位置插入节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#迭代方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self,num</span>):</span><br><span class="line">    <span class="comment">#如果树是空，初始化根节点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>._root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>._root = TreeNode(num)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment">#查找插入位置,我们还要保存cur的父节点</span></span><br><span class="line">    cur,pre = <span class="variable language_">self</span>._root,<span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> cur.val == num :</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        pre = cur</span><br><span class="line">        <span class="keyword">if</span> cur.val &lt; num :</span><br><span class="line">            cur  = cur.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = cur.left</span><br><span class="line">    <span class="comment">#插入节点</span></span><br><span class="line">    node = TreeNode(num)</span><br><span class="line">    <span class="keyword">if</span> pre.val &lt; num :</span><br><span class="line">        pre.right = node</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pre.left = node</span><br><span class="line">        </span><br><span class="line"><span class="comment">#递归方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self,val</span>):</span><br><span class="line">    <span class="comment">#插入节点主方法</span></span><br><span class="line">    <span class="variable language_">self</span>._root = <span class="variable language_">self</span>.insert_helper(<span class="variable language_">self</span>._root,val)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_helper</span>(<span class="params">self,node,val</span>):</span><br><span class="line">    <span class="comment">#插入节点辅助递归方法</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> TreeNode(val)  <span class="comment">#当前节点为空，找到位置，创建一个新节点</span></span><br><span class="line">    <span class="keyword">if</span> node.val == val:</span><br><span class="line">        <span class="keyword">return</span> node   <span class="comment">#值相等不允许重复插入，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> val &lt; node.val:</span><br><span class="line">        node.left = <span class="variable language_">self</span>.insert_helper(node.left,val)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node.right = <span class="variable language_">self</span>.insert_helper(node.right,val) <span class="comment">#递归插入左子树或者右子树</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> node </span><br></pre></td></tr></table></figure>







<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>先查找再删除，需要注意该节点的子节点</p>
<p>没有子节点，直接删除；有一个子节点，该子节点直接代替父节点；有两个节点：</p>
<p>——&gt;右子树的最小节点或者左子树的最大节点。</p>
<img src="D:\blog\lariblog\source\_posts\数据结构与算法\bst_remove_case3_step4.png" style="zoom:50%;" />



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self,num</span>):</span><br><span class="line">    <span class="comment">#如果树是空的，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>._root == <span class="literal">None</span> :</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment">#查找待删节点cur和其父节点pre</span></span><br><span class="line">    cur,pre = <span class="variable language_">self</span>._root,<span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur :</span><br><span class="line">        <span class="keyword">if</span> cur.val == num:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        pre = cur</span><br><span class="line">        <span class="keyword">if</span> cur.val &lt; num :</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = cur.left</span><br><span class="line">    <span class="comment">#如果没有找到，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> cur == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment">#开始分析cur 的子节点情况</span></span><br><span class="line">    <span class="comment">#如果有0/1个子节点</span></span><br><span class="line">    <span class="keyword">if</span> cur.left == <span class="literal">None</span> <span class="keyword">or</span> cur.right == <span class="literal">None</span>:</span><br><span class="line">        child = cur.left <span class="keyword">or</span> cur.right</span><br><span class="line">        <span class="comment">#如果cur是根节点</span></span><br><span class="line">        <span class="keyword">if</span> cur == <span class="variable language_">self</span>._root:</span><br><span class="line">            <span class="variable language_">self</span>._root = child</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> pre.left == cur:</span><br><span class="line">                pre.left = child</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.right = child</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#如果是两个子节点</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#查找剩下右子树的最小节点</span></span><br><span class="line">        tmp = cur.right</span><br><span class="line">        <span class="keyword">while</span> tmp.left:</span><br><span class="line">            tmp = tmp.left   </span><br><span class="line">        <span class="variable language_">self</span>.remove(tmp.val)</span><br><span class="line">        cur.val = tmp.val</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意最后        self.remove(tmp.val)<br>        cur.val &#x3D; tmp.val   顺序不能更换。</p>
</blockquote>
<h4 id="中序遍历有序"><a href="#中序遍历有序" class="headerlink" title="中序遍历有序"></a>中序遍历有序</h4><p>二叉树的中序遍历：左——&gt; 中——&gt;右 , 而二叉搜索树满足“左子节点 &lt; 根节点 &lt; 右子节点”的大小关系。<strong>二叉搜索树的中序遍历序列是升序的</strong>。</p>
<table>
<thead>
<tr>
<th></th>
<th>无序数组</th>
<th>二叉搜索树</th>
</tr>
</thead>
<tbody><tr>
<td>查找元素</td>
<td>O(n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>插入元素</td>
<td>O(1)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>删除元素</td>
<td>O(n)</td>
<td>O(log n)</td>
</tr>
</tbody></table>
<p>一种更简单的实现</p>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>需要频繁进行增删查改操作的场景中，AVL 树能始终保持高效的数据操作性能</p>
<p>是一种平衡二叉树。</p>
<h3 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h3><ul>
<li><p>节点高度 （需要为节点类添加height变量）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.height = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.left = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.right = <span class="literal">None</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">self,node</span>):</span><br><span class="line">        <span class="comment">#空节点为-1，叶子节点为0</span></span><br><span class="line">            <span class="keyword">if</span> node :</span><br><span class="line">                <span class="keyword">return</span> node.height  </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>    </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_height</span>(<span class="params">self,node</span>):</span><br><span class="line">        <span class="comment">#节点高度为最高子树高度 + 1</span></span><br><span class="line">            node.height = <span class="built_in">max</span>([<span class="variable language_">self</span>.height(node.left), <span class="variable language_">self</span>.height(node.right)]) + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里height 指的是该节点到最远的叶子节点的距离，也就是边的数量（有的定义不太一样) 叶节点的高度为 0 ，而空节点的高度为 -1.</p>
<p>在 AVLTree 中 node.height 是直接用的属性</p>
</blockquote>
</li>
<li><p>节点平衡因子</p>
<p>定义为：节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">balance_factor</span>(<span class="params">self,node</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.height(node.left)- <span class="variable language_">self</span>.height(<span class="variable language_">self</span>.right) </span><br><span class="line">           </span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设平衡因子为f ，那么一颗AVL树的任意节点的平衡因子都满足 -1 &lt;&#x3D; f &lt;&#x3D; 1</p>
</blockquote>
</li>
</ul>
<h3 id="AVL-树旋转"><a href="#AVL-树旋转" class="headerlink" title="AVL 树旋转"></a>AVL 树旋转</h3><p>旋转：是让其保持二叉搜索树的性质，也是将其变成平衡二叉树。</p>
<p>根据节点失衡情况分为四种 ： 右旋，左旋，右+左旋 左+右旋 </p>
<p>插入所导致的<strong>多个祖先</strong>失衡，只需要<strong>调节距离插入节点最近的失衡节点</strong>，其他节点自会平衡</p>
<img src="D:\blog\lariblog\source\_posts\数据结构与算法\ALV.png" style="zoom:%;" />

<h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p>插入位置为右孩子的右子树。该节点平衡因子与右孩子的平衡因子分别为 -2，-1</p>
<p>操作： 该节点右旋。</p>
<blockquote>
<p>两个失衡节点，只需要看最近的一个，即节点3 ， 3 作为node ，左孩子child 为1 </p>
</blockquote>
<img src="D:\blog\lariblog\source\_posts\数据结构与算法\avltree_right_rotate_step1.png" style="zoom:50%;" />

<img src="D:\blog\lariblog\source\_posts\数据结构与算法\avltree_right_rotate_step4.png" style="zoom:50%;" />

<blockquote>
<p>失衡节点想要右旋转的时候，如果左孩子还有右边孙子，需要添加一步骤，将grand_child 添加到node 左子节点。如下图</p>
</blockquote>
<img src="D:\blog\lariblog\source\_posts\数据结构与算法\avltree_right_rotate_with_grandchild.png" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span>:</span><br><span class="line">    <span class="comment">#LL形式</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">right_rorate</span>(<span class="params">self,node</span>):</span><br><span class="line">        child = node.left</span><br><span class="line">        grand = child.right</span><br><span class="line">        <span class="comment">#以child 为原点将node 右边旋转</span></span><br><span class="line">        child.right = node</span><br><span class="line">        node.left = grand</span><br><span class="line">        <span class="comment">#更新高度</span></span><br><span class="line">        <span class="variable language_">self</span>.update_height(node)</span><br><span class="line">        <span class="variable language_">self</span>.update_height(child)</span><br><span class="line">        <span class="comment">#返回旋转后子树的新的根节点</span></span><br><span class="line">        <span class="keyword">return</span> child</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>更新高度</strong>时只需要更新<strong>旋转过程中受到影响的节点</strong>，即父节点（<code>node</code>）和子节点（<code>child</code>）。<code>grand</code>（子节点的右子树）本身在旋转中没有被移动或修改，因此无需更新其高度。</p>
</blockquote>
<h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p>插入位置为左孩子的左子树。该节点和左孩子的平衡因子分别是2，1</p>
<p>操作：该节点左旋。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span>:</span><br><span class="line">    <span class="comment">#RR形式</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">left_rotate</span>(<span class="params">self,node</span>):</span><br><span class="line">        child = node.right</span><br><span class="line">        grand = child.left</span><br><span class="line">        <span class="comment">#以child 为原点将node 左边旋转</span></span><br><span class="line">        child.left = node</span><br><span class="line">        node.right = grand</span><br><span class="line">        <span class="comment">#更新高度</span></span><br><span class="line">        <span class="variable language_">self</span>.update_height(node)</span><br><span class="line">        <span class="variable language_">self</span>.update_height(child)</span><br><span class="line">        <span class="comment">#返回旋转后子树的新的根节点</span></span><br><span class="line">        <span class="keyword">return</span> child</span><br></pre></td></tr></table></figure>



<h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p>插入位置为左孩子的右子树。该节点和左孩子的平衡因子分别是2，-1</p>
<p>操作：左孩子左旋，该节点右旋</p>
<h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p>插入位置为右孩子的左子树。该节点和右孩子的平衡因子分别是-2，1</p>
<p>操作：右孩子右旋，该节点左旋</p>
<p>为了便于操作，我们可以将四种操作封装。</p>
<table>
<thead>
<tr>
<th>失衡节点的平衡因子</th>
<th>子节点的平衡因子</th>
<th>应采用的旋转方法</th>
</tr>
</thead>
<tbody><tr>
<td>&gt; 1（左偏树）</td>
<td>&gt;&#x3D;0</td>
<td>右旋</td>
</tr>
<tr>
<td>&gt; 1 （左偏树）</td>
<td>&lt;0</td>
<td>先左旋后右旋</td>
</tr>
<tr>
<td>&lt; -1 （右偏树）</td>
<td>&lt;&#x3D; 0</td>
<td>左旋</td>
</tr>
<tr>
<td>&lt; -1 （右偏树）</td>
<td>&gt;0</td>
<td>先右旋后左旋</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self,node</span>):</span><br><span class="line">        <span class="comment">#获取失衡节点的平衡因子</span></span><br><span class="line">        balance_factor = <span class="variable language_">self</span>.balance_factor(node)</span><br><span class="line">        <span class="comment">#l 左偏树</span></span><br><span class="line">        <span class="keyword">if</span> balance_factor &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="comment">#是LL 还是LR:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.balance_factor(node.left) &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">self</span>.right_rorate(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#左孩子左旋</span></span><br><span class="line">                node.left = <span class="variable language_">self</span>.left_rotate(node.left)</span><br><span class="line">                <span class="comment">#该节点右旋</span></span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">self</span>.right_rorate(node)</span><br><span class="line">        <span class="comment">#r 右偏树</span></span><br><span class="line">        <span class="keyword">elif</span> balance_factor &lt; -<span class="number">1</span>:</span><br><span class="line">            <span class="comment">#是RR 还是RL:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.balance_factor(node.right) &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">self</span>.left_rotate(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#右孩子右旋</span></span><br><span class="line">                node.right = <span class="variable language_">self</span>.right_rorate(node.right)</span><br><span class="line">                <span class="comment">#该节点左旋</span></span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">self</span>.left_rotate(node)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="AVL树常用操作"><a href="#AVL树常用操作" class="headerlink" title="AVL树常用操作"></a>AVL树常用操作</h3><h4 id="插入节点-1"><a href="#插入节点-1" class="headerlink" title="插入节点"></a>插入节点</h4><p>与二叉搜索树的操作类似，不过要处理失衡节点。<strong>我们需要从这个节点开始，自底向上执行旋转操作，使所有失衡节点恢复平衡</strong>。</p>
<ol>
<li>递归遍历树，找到插入位置，插入新节点。</li>
<li>递归返回时，更新当前节点的高度</li>
<li>检查当前节点的平衡因子，执行适当的旋转</li>
<li>平衡后的子树返回给父节点，最终返回新的根节点。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self,val</span>):</span><br><span class="line">    <span class="variable language_">self</span>._root = <span class="variable language_">self</span>.insert_helper(<span class="variable language_">self</span>._root,val)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_helper</span>(<span class="params">self,node,val</span>):</span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">    <span class="keyword">if</span> node.val == val:    </span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> node.val &lt; val:</span><br><span class="line">        node.right = <span class="variable language_">self</span>.insert_helper(node.right,val)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node.left = <span class="variable language_">self</span>.insert_helper(node.left,val)</span><br><span class="line">    <span class="comment">#更新高度</span></span><br><span class="line">    <span class="variable language_">self</span>.update_height(node)</span><br><span class="line">    <span class="comment">#旋转</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.rotate(node)</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h4 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self,val</span>):</span><br><span class="line">    <span class="variable language_">self</span>._root = <span class="variable language_">self</span>.remove_helper(<span class="variable language_">self</span>._root,val)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_helper</span>(<span class="params">self,node,val</span>):</span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> node.val &lt; val:</span><br><span class="line">        node.right = <span class="variable language_">self</span>.remove_helper(node.right,val)</span><br><span class="line">    <span class="keyword">elif</span> node.val &gt; val:</span><br><span class="line">        node.left = <span class="variable language_">self</span>.remove_helper(node.left,val)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#有0/1个子节点</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            child = node.left <span class="keyword">or</span> node.right</span><br><span class="line">            <span class="keyword">return</span> child</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp = node.right</span><br><span class="line">            <span class="keyword">while</span> tmp.left :</span><br><span class="line">                tmp = tmp.left</span><br><span class="line">            node.right = <span class="variable language_">self</span>.remove_helper(node.right,tmp.val)    </span><br><span class="line">            node.val = tmp.val</span><br><span class="line">    <span class="variable language_">self</span>.update_height(node)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.rotate(node)   </span><br></pre></td></tr></table></figure>

<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">height</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(height(root.left),height(root.right))+<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="二叉树相同，对称，平衡，右视图"><a href="#二叉树相同，对称，平衡，右视图" class="headerlink" title="二叉树相同，对称，平衡，右视图"></a>二叉树相同，对称，平衡，右视图</h3><ul>
<li><p>相同(p,q,为treenode)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_same</span>(<span class="params">p,q</span>):</span><br><span class="line">    <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> q <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> p <span class="keyword">is</span> q</span><br><span class="line">    <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> <span class="variable language_">self</span>.is_same(p.left,q.left) <span class="keyword">and</span></span><br><span class="line"><span class="variable language_">self</span>.is_same(p.right,q.right)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>对称（相较于相同，把最后改成对比左右）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_same</span>(<span class="params">p,q</span>):</span><br><span class="line">    <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> q <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> p <span class="keyword">is</span> q</span><br><span class="line">    <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> <span class="variable language_">self</span>.is_same(p.left,q.right) <span class="keyword">and</span> <span class="variable language_">self</span>.is_same(p.right,q.left)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_symmetric</span>(<span class="params">self,root</span>):</span><br><span class="line">    <span class="keyword">return</span> is_same(root.left,root.right)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>平衡</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isblance</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_height</span>(<span class="params">node</span>):</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        left_height = get_height(node.left)</span><br><span class="line">        <span class="keyword">if</span> left_height == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        right_height = get_height(node.right)</span><br><span class="line">        <span class="keyword">if</span> right_height == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(left_height - right_height) &gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_height,right_height) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> get_height(root) != -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>右视图（深度等于答案长度才添加进去,先递归调用右子树）</p>
<p>左视图：先递归调用左子树</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rightsideview</span>(<span class="params">root</span>):</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">node,depth</span>):</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> depth==<span class="built_in">len</span>(ans):</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">        f(node.right,depth+<span class="number">1</span>)</span><br><span class="line">        f(node.left,depth+<span class="number">1</span>)</span><br><span class="line">    f(root,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="验证二叉树是不是二叉搜索树"><a href="#验证二叉树是不是二叉搜索树" class="headerlink" title="验证二叉树是不是二叉搜索树"></a>验证二叉树是不是二叉搜索树</h3><ul>
<li><p>前序遍历 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isvalidbst</span>(<span class="params">root,left= -inf,right = inf</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    x = root.val</span><br><span class="line">    <span class="keyword">return</span> left &lt; x &lt; right <span class="keyword">and</span> isvalidbst(root.left,left,x) <span class="keyword">and</span> isvalidbst(root.right,x,right)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>中序遍历（递增）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isvalidbst</span>(<span class="params">root</span>):</span><br><span class="line">    pre = -inf</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isvalidbst(root.left):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> root.val &lt; pre:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    pre = root.val</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isvaildbst(root.right)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h3><ul>
<li><p>二叉树的公共祖先（公共许仙可以包含自己）</p>
<blockquote>
<p>![](C:\Users\86151\Pictures\Screenshots\屏幕截图 2024-12-21 182612.png)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lowercommonancestor</span>(<span class="params">root,p,q</span>):</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root <span class="keyword">is</span> p <span class="keyword">or</span> root <span class="keyword">is</span> q:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    left = lowercommonancestor(root.left,p,q)</span><br><span class="line">    right = lowercommonancestor(root.right,p,q)</span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">if</span> left :</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>递归返回的结果的 p&#x2F;q&#x2F;none&#x2F;最近公共祖先  返回谁代表着公共祖先在谁之上</p>
</blockquote>
</li>
<li><p>二叉搜索树的最近公共祖先</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span>  <span class="title function_">lowercommonancestor</span>(<span class="params">root,p,q</span>):</span><br><span class="line">    x = root.val</span><br><span class="line">    <span class="keyword">if</span> p.val &lt; x <span class="keyword">and</span> q.val &lt; x:</span><br><span class="line">        <span class="keyword">return</span> lowercommonancestor(root.left,p,q)</span><br><span class="line">    <span class="keyword">if</span> p.val &gt; x <span class="keyword">and</span> q.val &gt; x:</span><br><span class="line">        <span class="keyword">return</span> lowercommonancestor(root.right,p,q)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆是一种满足特定条件的完全二叉树（只有底层节点未被排满）</p>
<ul>
<li>小顶堆（min heap）：任意节点的值 ≤ 其子节点的值。</li>
<li>大顶堆（max heap）：任意节点的值 ≥ 其子节点的值。</li>
</ul>
<img src="D:\blog\lariblog\source\_posts\数据结构与算法\min_heap_and_max_heap.png" style="zoom:50%;" />

<p>特点：</p>
<ul>
<li>最低层节点但靠左填充，其他层都是填满状态</li>
<li>二叉树的根节点为<strong>堆顶</strong>，底层靠右的节点为<strong>堆底</strong></li>
</ul>
<blockquote>
<p>堆应用：</p>
<p>优先队列，出队入队为0（logn） 建队为0（n）</p>
<p>堆排序</p>
<p>获取最大的K个元素</p>
</blockquote>
<p>在 Python 中，<code>heapq</code> 模块提供了对小顶堆的支持（默认实现）。但为了实现大顶堆，可以通过“将元素取负”来颠倒堆的大小关系。</p>
<h2 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h2><ul>
<li>堆的存储与表示</li>
</ul>
<p>用数组来存储堆，节点指针通过索引映射公式来进行表示 			</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">left</span>(<span class="params">self, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取左子节点的索引&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">right</span>(<span class="params">self, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取右子节点的索引&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">self, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取父节点的索引&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) // <span class="number">2</span>  <span class="comment"># 向下整除</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>访问堆顶元素 （二叉树的根节点，也是列表的首个元素）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;访问堆顶元素&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.max_heap[<span class="number">0</span>] </span><br></pre></td></tr></table></figure>
</li>
<li><p>元素入堆</p>
<p>val正常插入到堆底，维护堆的成立条件，修复<strong>从插入节点到根节点的路径上的各个节点</strong> ——&gt; 堆化</p>
<p>逐个比较插入节点和父节点的值，交换两个节点的值 ——&gt; 直到越过根节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,value</span>):</span><br><span class="line">    <span class="variable language_">self</span>.max_heap.append(value) <span class="comment">#添加节点</span></span><br><span class="line">    <span class="variable language_">self</span>.sift_up(<span class="variable language_">self</span>.size()-<span class="number">1</span>) <span class="comment">#从底部到顶部堆化</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sift_up</span>(<span class="params">self,index</span>):</span><br><span class="line">    <span class="comment">#从节点imdex开始，从底部向上堆化</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        parent = <span class="variable language_">self</span>.parent(index)</span><br><span class="line">        <span class="keyword">if</span> parent &lt;<span class="number">0</span> <span class="keyword">or</span> <span class="variable language_">self</span>.max_heap[parent] &gt;= <span class="variable language_">self</span>.max_heap[index]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="variable language_">self</span>.swap(parent,index)  <span class="comment">#交换值</span></span><br><span class="line">        index = parent  <span class="comment">#更新下标</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>while True 是一个无限循环，直到遇到break。</p>
<p>while parent &gt;&#x3D; 0 and self.max_heap[parent] &lt; self.max_heap[index]  等同逻辑</p>
</blockquote>
</li>
<li><p>栈顶元素出栈</p>
<ol>
<li>交换栈顶元素和栈底元素（交换更节电和最右边节点）</li>
<li>交换完成之后直接删除最末尾元素</li>
<li>然后从根节点开始，从顶部往底部堆化</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.is_empty():</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">&quot;堆为空&quot;</span>)</span><br><span class="line">    <span class="variable language_">self</span>.sawp(<span class="number">0</span>,<span class="variable language_">self</span>.size()-<span class="number">1</span>)</span><br><span class="line">    val = <span class="variable language_">self</span>.max_heap.pop()</span><br><span class="line">    <span class="variable language_">self</span>.sift_down(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> val </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sift_down</span>(<span class="params">self,index</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        left = <span class="variable language_">self</span>.left(index)</span><br><span class="line">        right = <span class="variable language_">self</span>.right(index)</span><br><span class="line">        largest = index</span><br><span class="line">        <span class="keyword">if</span> left &lt; <span class="variable language_">self</span>.size() <span class="keyword">and</span> <span class="variable language_">self</span>.max_heap[left] &gt;<span class="variable language_">self</span>.max_heap[largest]:</span><br><span class="line">            largest = left</span><br><span class="line">        <span class="keyword">if</span> right &lt; <span class="variable language_">self</span>.size() <span class="keyword">and</span> <span class="variable language_">self</span>.max_heap[right] &gt; <span class="variable language_">self</span>.max_heap[largest]:</span><br><span class="line">            largest = right</span><br><span class="line">        <span class="keyword">if</span> largest == index:</span><br><span class="line">            <span class="keyword">break</span> </span><br><span class="line">        <span class="variable language_">self</span>.swap(largest,index)   <span class="comment">#交换节点</span></span><br><span class="line">        index = largest    <span class="comment">#更新下标</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在向下堆化的过程中，需要将index 与左右孩子进行比较，把大值换上去。直到左右孩子都小于自己。我们设置了一个临时最大值，初始假设为本节点</p>
</blockquote>
</li>
</ul>
<h2 id="建堆操作"><a href="#建堆操作" class="headerlink" title="建堆操作"></a>建堆操作</h2><h3 id="借助入堆操作实现"><a href="#借助入堆操作实现" class="headerlink" title="借助入堆操作实现"></a>借助入堆操作实现</h3><p>建立空堆，在底部入堆（树： logn），对该元素执行从底部至顶部的堆化。(nlogn). 由于节点是从顶到底依次被添加进二叉树的，因此堆是“自上而下”构建的。</p>
<h3 id="借助遍历堆化"><a href="#借助遍历堆化" class="headerlink" title="借助遍历堆化"></a>借助遍历堆化</h3><ol>
<li><p>将列表所有元素原封不动地添加到堆中，此时堆的性质尚未得到满足。</p>
</li>
<li><p>倒序遍历堆（层序遍历的倒序），依次对每个非叶节点执行“从顶至底堆化”。</p>
</li>
</ol>
<p><strong>每当堆化一个节点后，以该节点为根节点的子树就形成一个合法的子堆</strong>。而由于是倒序遍历，因此堆是“自下而上”构建的  <strong>倒序遍历</strong>—— 保证当前节点下面都是合理的堆。</p>
<p>叶子节点无需堆化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,nums</span>):</span><br><span class="line">   <span class="variable language_">self</span>.max_heap = nums</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.size()-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">       <span class="variable language_">self</span>.down(i)</span><br></pre></td></tr></table></figure>

<h2 id="top-k-问题"><a href="#top-k-问题" class="headerlink" title="top-k 问题"></a>top-k 问题</h2><blockquote>
<p>给定长度为 n 的无序数组，返回数组中最大的 k个元素。</p>
</blockquote>
<ul>
<li><p>遍历k 次</p>
<p>每次都取出当前最大元素</p>
</li>
<li><p>排序</p>
<p>而后返回K个元素</p>
</li>
<li><p>堆</p>
<ol>
<li>初始化一个小顶堆，其堆顶元素最小。</li>
<li>先将数组的前 k 个元素依次入堆。</li>
<li>从第 k+1 个元素开始，若当前元素大于堆顶元素，则将堆顶元素出堆，并将当前元素入堆。</li>
<li>遍历完成后，堆中保存的就是最大的 k 个元素</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">top_heap</span>(<span class="params">nums,k</span>):</span><br><span class="line">    heap = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        heap.append(nums[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; heap[<span class="number">0</span>]:</span><br><span class="line">            heapq.heappop(heap)</span><br><span class="line">            heapq.heappush(heap,nums[i])</span><br><span class="line">    <span class="string">&quot;&quot;&quot;for num in nums:</span></span><br><span class="line"><span class="string">        if len(heap) &lt;k:</span></span><br><span class="line"><span class="string">            heapq.heappush(heap,num)            </span></span><br><span class="line"><span class="string">        else:    </span></span><br><span class="line"><span class="string">            if num &gt; heap[0]:</span></span><br><span class="line"><span class="string">                heapq.heappop(heap)</span></span><br><span class="line"><span class="string">                heapq.heappush(heap,num) &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line">                </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><ul>
<li><p>邻接矩阵 </p>
<p>图的顶点数量为 n ，邻接矩阵（adjacency matrix）使用一个 n×n 大小的矩阵来表示图。每一行（列）代表一个顶点，矩阵元素代表边，用 1 或 0 表示两个顶点之间是否存在边。</p>
<img src="D:\blog\lariblog\source\_posts\数据结构与算法\adjacency_matrix.png" style="zoom:50%;" /></li>
</ul>
<blockquote>
<p>以邻接矩阵作为图的表示,我们进行增删查改的操作效率会提高,但是空间复杂度也会提高</p>
</blockquote>
<ul>
<li><p>邻接表 </p>
<p>对于一个图.用n 个链表来表示图,链表的节点表示顶点,第i个链表对应顶点i,其中储存该顶点的所有邻接顶点.</p>
<img src="D:\blog\lariblog\source\_posts\数据结构与算法\adjacency_list.png" style="zoom:50%;" /></li>
</ul>
<blockquote>
<p>邻接表与哈希表中的链式结构相似</p>
</blockquote>
<h2 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h2><h3 id="对邻接矩阵的操作"><a href="#对邻接矩阵的操作" class="headerlink" title="对邻接矩阵的操作"></a>对邻接矩阵的操作</h3><ul>
<li><strong>添加或删除边</strong>：直接在邻接矩阵中修改指定的边即可，使用 O(1) 时间。而由于是无向图，因此需要同时<strong>更新两个方向的边</strong>。</li>
<li><strong>添加顶点</strong>：在邻接矩阵的<strong>尾部</strong>添加一行一列，并全部填 0 即可，使用 O(n) 时间。</li>
<li><strong>删除顶点</strong>：在邻接矩阵中删除一行一列。当删除首行首列时达到最差情况，需要将 (n−1)**2 个元素“向左上移动”，从而使用 O(n2) 时间。</li>
<li><strong>初始化</strong>：传入 n 个顶点，初始化长度为 n 的顶点列表 <code>vertices</code> ，使用 O(n) 时间；初始化 n×n 大小的邻接矩阵 <code>adjMat</code> ，使用 O(n2) 时间。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjMat</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,vertices:<span class="built_in">list</span>,edges:<span class="built_in">list</span>[<span class="built_in">list</span>]</span>):</span><br><span class="line">        <span class="comment">#每个边有两个顶点的索引组成。[0,1]，代表这两个顶点之间有一条边。</span></span><br><span class="line">        <span class="variable language_">self</span>.vertices = []  <span class="comment">#顶点列表，索引--&gt;顶点索引。 值--&gt; 顶点值</span></span><br><span class="line">        <span class="variable language_">self</span>.adj_mat = [] <span class="comment">#邻接矩阵，里面是每一行的元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> vertice <span class="keyword">in</span> vertices:</span><br><span class="line">            <span class="variable language_">self</span>.add_vertex(vertice)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#添加边 </span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="variable language_">self</span>.add_edge(e[<span class="number">0</span>],e[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.vertices)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_vertex</span> (<span class="variable language_">self</span>,val):</span><br><span class="line">        n = <span class="variable language_">self</span>.size()</span><br><span class="line">        <span class="comment">#添加新顶点</span></span><br><span class="line">        <span class="variable language_">self</span>.vertices.append(val)</span><br><span class="line">        new_row = [<span class="number">0</span>]*n </span><br><span class="line">        <span class="comment">#添加新行</span></span><br><span class="line">        <span class="variable language_">self</span>.adj_mat.append(new_row)</span><br><span class="line">        <span class="comment">#添加新列</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="variable language_">self</span>.adj_mat:</span><br><span class="line">            row.append(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_vertex</span>(<span class="params">self,index</span>):</span><br><span class="line">        <span class="keyword">if</span> index &gt; <span class="variable language_">self</span>.size()-<span class="number">1</span> :</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;顶点索引越界&#x27;</span>)</span><br><span class="line">        <span class="comment">#删除顶点</span></span><br><span class="line">        <span class="variable language_">self</span>.vertices.pop(index)</span><br><span class="line">        <span class="comment">#删除行</span></span><br><span class="line">        <span class="variable language_">self</span>.adj_mat.pop(index)</span><br><span class="line">        <span class="comment">#删除列</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="variable language_">self</span>.adj_mat:</span><br><span class="line">            row.pop(index)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_edge</span>(<span class="params">self,i,j</span>):</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt;<span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="variable language_">self</span>.size()-<span class="number">1</span> <span class="keyword">or</span> j &gt;= <span class="variable language_">self</span>.size()-<span class="number">1</span> <span class="keyword">or</span> i == j:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;顶点索引越界&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.adj_mat[i][j] = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.adj_mat[j][i] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_edge</span>(<span class="params">self,i,j</span>):</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt;<span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="variable language_">self</span>.size()-<span class="number">1</span> <span class="keyword">or</span> j &gt;= <span class="variable language_">self</span>.size()-<span class="number">1</span> <span class="keyword">or</span> i ==j :</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;顶点索引越界&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.adj_mat[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.adj_mat[j][i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;顶点：&quot;</span>,<span class="variable language_">self</span>.vertices)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;邻接矩阵：&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="variable language_">self</span>.adj_mat:</span><br><span class="line">            <span class="built_in">print</span>(row)</span><br><span class="line">            </span><br></pre></td></tr></table></figure>





<h3 id="对邻接表的实现"><a href="#对邻接表的实现" class="headerlink" title="对邻接表的实现"></a>对邻接表的实现</h3><ul>
<li><strong>添加边</strong>：在顶点对应链表的末尾添加边即可，使用 O(1) 时间。因为是无向图，所以需要同时添加两个方向的边。</li>
<li><strong>删除边</strong>：在顶点对应链表中查找并删除指定边，使用 O(m) 时间。在无向图中，需要同时删除两个方向的边。</li>
<li><strong>添加顶点</strong>：在邻接表中添加一个链表，并将新增顶点作为链表头节点，使用 O(1) 时间。</li>
<li><strong>删除顶点</strong>：需遍历整个邻接表，删除包含指定顶点的所有边，使用 O(n+m) 时间。</li>
<li><strong>初始化</strong>：在邻接表中创建 n 个顶点和 2m 条边，使用 O(n+m) 时间。</li>
</ul>
<blockquote>
<p>列表来代替链表，哈希表来储存邻接表，键——&gt; 顶点  值——&gt;</p>
<p>与该顶点相连的所有顶点</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjList</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于邻接表实现的图&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,edges</span>):</span><br><span class="line">        <span class="variable language_">self</span>.adj_list = <span class="built_in">dict</span>()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.adj_list)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_edge</span>(<span class="params">self,v1,v2</span>):</span><br><span class="line">        <span class="keyword">if</span> v1 <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list <span class="keyword">or</span> v2 <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list <span class="keyword">or</span> v1 == v2:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;顶点不存在/不能自环&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.adj_list[v1].append(v2)</span><br><span class="line">        <span class="variable language_">self</span>.adj_list[v2].append(v1)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_edge</span>(<span class="params">self,v1,v2</span>):</span><br><span class="line">        <span class="keyword">if</span> v1 <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list <span class="keyword">or</span> v2 <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list <span class="keyword">or</span> v1 == v2:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;顶点不存在&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.adj_list[v1].remove(v2)</span><br><span class="line">        <span class="variable language_">self</span>.adj_list[v2].remove(v1)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_vertex</span>(<span class="params">self,v</span>):</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;顶点已存在&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.adj_list[v] = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_vertex</span>(<span class="params">self,v</span>):</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;顶点不存在&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.adj_list.pop(v)</span><br><span class="line">        <span class="comment">#遍历其他顶点链表，删除所有包含vet 的边</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list:</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list[key]:</span><br><span class="line">                <span class="variable language_">self</span>.adj_list[key].remove(v)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;邻接表：&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.adj_list:</span><br><span class="line">            <span class="built_in">print</span>(key,<span class="variable language_">self</span>.adj_list[key])</span><br><span class="line">            </span><br></pre></td></tr></table></figure>





<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="评价维度"><a href="#评价维度" class="headerlink" title="评价维度"></a>评价维度</h2><ul>
<li><p>运行效率：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。</p>
</li>
<li><p>就地性：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。</p>
</li>
<li><p>稳定性：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。</p>
</li>
</ul>
<p>稳定排序是多级排序场景的必要条件。假设我们有一个存储学生信息的表格，第 1 列和第 2 列分别是姓名和年龄。在这种情况下，非稳定排序可能导致输入数据的有序性丧失<br>自适应性：自适应排序能够利用输入数据已有的顺序信息来减少计算量，达到更优的时间效率。自适应排序算法的最佳时间复杂度通常优于平均时间复杂度。</p>
<p>任何需要转换或者以排序顺序保存的数据都将涉及项目的比较。<br><img src="C:\Users\86151\Pictures\Screenshots\屏幕截图 2024-10-21 155019.png" alt="屏幕截图 2024-10-21 155019" style="zoom:50%;" /></p>
<blockquote>
<p>字符串按照ascll 码来进行排序<br>类中的比较，需要覆盖重写 <code>__eq__</code> <code>__gt__</code>(相等，大于)函数</p>
</blockquote>
<h2 id="python-内置排序函数"><a href="#python-内置排序函数" class="headerlink" title="python 内置排序函数"></a>python 内置排序函数</h2><p>sorted 函数 </p>
<ul>
<li>不会更改原有的可迭代对象（比如列表&#x2F;字符串），而是生成一个新的列表&#x2F;字符串&#x2F;<blockquote>
<p>字符串仍然按照ascll 码<br>sort 函数</p>
</blockquote>
</li>
<li>仅仅对列表有用，会更改原有列表</li>
</ul>
<h2 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h2><p>假设元素都是储存在类数组中，储存地址的是连续的，address &#x3D; start+index也就是说里面的元素可以通过索引直接访问。<br>这个操作的复杂度为O(1)  可以用来实现 快速，归并，堆，插入等排序</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>原理：<br>设数组的长度为 n ，选择排序的算法流程如下图所示。</p>
<ol>
<li>初始状态下，所有元素未排序，即未排序（索引）区间为 [0, n-1] 。</li>
<li>选取区间 [0, n-1] 中的最小元素，将其与索引 0 处的元素交换。完成后，数组前 1 个元素已排序。</li>
<li>选取区间 [1, n-1] 中的最小元素，将其与索引 1 处的元素交换。完成后，数组前 2 个元素已排序。</li>
<li>以此类推。经过 n - 1 轮选择与交换后，数组前 n - 1 个元素已排序。</li>
<li>仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。</li>
</ol>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;选择排序&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 外循环：未排序区间为 [i, n-1]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内循环：找到未排序区间内的最小元素 [i+1,n-1]</span></span><br><span class="line">        k = i    </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[k]:</span><br><span class="line">                k = j  <span class="comment"># 记录最小元素的索引</span></span><br><span class="line">        <span class="comment"># 将该最小元素与未排序区间的首个元素交换</span></span><br><span class="line">        nums[i], nums[k] = nums[k], nums[i]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里外层循环不考虑最后一个元素！！！只是循环不考虑，但是未排序的区间仍然是不变的<br>因为当排序进行到最后一步的时候，最后一个元素一定是最大的。 但是内层循环组要考虑，毕竟是从未排序的区间中找到最小的。<br>内层循环从i+1 开始的原因 ： 因为当前未排序区间的第一个元素已经是当前区间的最小值，不需要再次比较。</p>
</blockquote>
<p>另外一种思路是</p>
<img src="C:\Users\86151\Pictures\Screenshots\屏幕截图 2024-10-21 162944.png" alt="屏幕截图 2024-10-21 162944" style="zoom:50%;" />


  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">values</span>):</span><br><span class="line">	  unsorted_len = <span class="built_in">len</span>(values)</span><br><span class="line">	  <span class="keyword">while</span> unsorted_len &gt;<span class="number">1</span>:</span><br><span class="line">        unsorted = values[:unsorted_len]</span><br><span class="line">        largest = <span class="built_in">max</span>(unsorted)</span><br><span class="line">        index_largest = unsorted.index(largetst)</span><br><span class="line">        swap2_compact(values,index_largest,unsorted_len-<span class="number">1</span>)</span><br><span class="line">        unsorted_len -=<span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap2_compact</span>(<span class="params">values,i,j</span>):</span><br><span class="line">    values[i],values[j] = values[j],values[i]</span><br></pre></td></tr></table></figure>
<h4 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h4><p>时间复杂度为O(n**2)，非自适应排序<br>空间复杂度为O(1),原地排序<br>非稳定型排序 </p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>通过连续地比较与<strong>交换相邻</strong>元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。</p>
<p>设数组的长度为 n ，冒泡排序的步骤如下图所示。</p>
<ol>
<li>首先，对 n 个元素执行“冒泡”，<strong>将数组的最大元素交换至正确位置</strong>。</li>
<li>接下来，对剩余 n - 1 个元素执行“冒泡”，<strong>将第二大元素交换至正确位置</strong>。</li>
<li>以此类推，经过 n - 1 轮“冒泡”后，<strong>前 n - 1 大的元素都被交换至正确位置</strong>。</li>
<li>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。</li>
</ol>
<img src="C:\Users\86151\Pictures\Screenshots\屏幕截图 2024-10-21 164300.png" alt="屏幕截图 2024-10-21 164300" style="zoom:50%;" />


  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;冒泡排序&quot;&quot;&quot;</span></span><br><span class="line">  n = <span class="built_in">len</span>(nums)</span><br><span class="line">  <span class="comment">#外循环：未排序区间为 [0, i]</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">      <span class="comment"># 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端[0,i-1] 中找最大的，将其与 [i] 进行交换</span></span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">          <span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">              <span class="comment"># 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">              nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>外层循环从len(nums)- 1 开始的原因是，当进行到最后一步的时候，一定是最小的元素被剩余下来。<br>与选择排序不同的是，在内层循环中没有用一个变量来记录最大值，因为冒泡排序只是牵涉相邻元素的交换。<br>内层循环不包括当前未排序区间的最后一位，因为当前未排序区间的最后一个元素已经是当前区间的最大值，不需要再次比较。</p>
</blockquote>
<h4 id="效率优化"><a href="#效率优化" class="headerlink" title="效率优化"></a>效率优化</h4><p>设置一个标志位flag 来进行检测，如果某轮冒泡排序没有进行任何交换操作，说明该数组已经完成排序，可以直接返回结果。<br>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dubble_sort_with_flag</span>(<span class="params">nums:<span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">#外循环：未进行排序的区间为[0，i]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 内循环： 将未排序的区间中[0,i]中的最大元素交换到该区间的最右边</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; num[j+<span class="number">1</span>]:</span><br><span class="line">                nums[j],nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>],nums[j]</span><br><span class="line">                flag = true</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            	  <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="算法特性-1"><a href="#算法特性-1" class="headerlink" title="算法特性"></a>算法特性</h4><p>时间复杂度为O(n**2)<br>空间复杂度为O(1)，原地排序<br>稳定排序： 在冒泡中遇到相同元素不进行交换。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>工作原理与手动整理一副牌的过程相似。<br>也就是在<strong>未排序区间</strong>中选择一个基准元素，将该元素与其左侧已排序区间的元素注意比较大小，并将该元素插入到正确的位置。<br>设基准元素为 base ，我们需要将从目标索引到 base 之间的所有元素向右移动一位，然后将 base 赋值给目标索引。</p>
<img src="C:\Users\86151\Pictures\Screenshots\屏幕截图 2024-10-23 133934.png" alt="屏幕截图 2024-10-23 133934" style="zoom:50%;" />
1.初始状态下，数组的第 1 个元素已完成排序。
2.选取数组的第 2 个元素作为 base ，将其插入到正确位置后，数组的前 2 个元素已排序。
3.选取第 3 个元素作为 base ，将其插入到正确位置后，数组的前 3 个元素已排序。
4.以此类推，在最后一轮中，选取最后一个元素作为 base ，将其插入到正确位置后，所有元素均已排序。 

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;插入排序&quot;&quot;&quot;</span></span><br><span class="line">  <span class="comment"># 外循环：已排序区间为 [0, i-1]</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">      base = nums[i]</span><br><span class="line">      j = i - <span class="number">1</span></span><br><span class="line">      <span class="comment"># 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置</span></span><br><span class="line">      <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] &gt; base:</span><br><span class="line">          nums[j + <span class="number">1</span>] = nums[j]  <span class="comment"># 将 nums[j] 向右移动一位</span></span><br><span class="line">          j -= <span class="number">1</span></span><br><span class="line">      nums[j + <span class="number">1</span>] = base  <span class="comment"># 将 base 赋值到正确位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>与选择排序，冒泡排序不同的是，插入排序更加关注已经排序的区间是多少。[0:i-1]<br>外层循环从1 开始的原因是，第一个元素时已经排好序的。<br>然后需要从前面暂时排好序的开始进行与基准情况进行比较（找到适合他的位置）</p>
</blockquote>
<h4 id="算法特性-2"><a href="#算法特性-2" class="headerlink" title="算法特性"></a>算法特性</h4><p>时间复杂度O(n**2)<br>空间复杂度 原地排序<br>稳定排序 </p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>是一种根据分治策略的排序算法。快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧</p>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>是一种基于分治策略的高效搜索算法。它利用数据的有序性，每轮缩小一半搜索范围，直至找到目标元素或搜索区间为空为止。</p>
<blockquote>
<p>需要注意的是，first 和last 都是int 类型，i+j 可能会超出int 类型的取值范围。所以mid &#x3D; （i+（j-i））&#x2F;&#x2F;2</p>
</blockquote>
<p>有两种方法，一个使用循环，一个使用递归<br>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">  <span class="string">&quot;&quot;&quot;二分查找（双闭区间）&quot;&quot;&quot;</span></span><br><span class="line">  <span class="comment"># 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素</span></span><br><span class="line">  i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">  <span class="comment"># 循环，当搜索区间为空时跳出（当 i &gt; j 时为空）</span></span><br><span class="line">  <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">      <span class="comment"># 理论上 Python 的数字可以无限大（取决于内存大小），无须考虑大数越界问题</span></span><br><span class="line">      m = (i + j) // <span class="number">2</span>  <span class="comment"># 计算中点索引 m</span></span><br><span class="line">      <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">          i = m + <span class="number">1</span>  <span class="comment"># 此情况说明 target 在区间 [m+1, j] 中</span></span><br><span class="line">      <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">          j = m - <span class="number">1</span>  <span class="comment"># 此情况说明 target 在区间 [i, m-1] 中</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">return</span> m  <span class="comment"># 找到目标元素，返回其索引</span></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 未找到目标元素，返回 -1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>递归写法<br>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">nums,first,last,target</span>):</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> first &gt; last :</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    mid = (first + last)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        mid = (first + last)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> target &gt; mid</span><br><span class="line">            index = binary_search(nums,mid+<span class="number">1</span>,last,target)</span><br><span class="line">        <span class="keyword">elif</span> target &lt; mid :</span><br><span class="line">            index = binary_search(nums,first,mid-<span class="number">1</span>,target)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> index = mid</span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>局限性<br>仅仅适用于有序数组，在小数据中可以考虑新型查找。</p>
</blockquote>
<h4 id="二分查找插入点"><a href="#二分查找插入点" class="headerlink" title="二分查找插入点"></a>二分查找插入点</h4><p>二分查找不仅可用于搜索目标元素，还可用于解决许多变种问题，比如搜索目标元素的插入位置</p>
<h5 id="无重复元素的情况"><a href="#无重复元素的情况" class="headerlink" title="无重复元素的情况"></a>无重复元素的情况</h5><blockquote>
<p>给定一个长度为 n的有序数组 nums 和一个元素 target ，数组不存在重复元素。现将 target 插入数组 nums 中，并保持其有序性。若数组中已存在元素 target ，则插入到其左方。请返回插入后 target 在数组中的索引</p>
</blockquote>
<ul>
<li>问题一：当数组中包含 target 时，插入点的索引是否是该元素的索引？</li>
</ul>
<blockquote>
<p>题目要求将 target 插入到相等元素的左边，这意味着新插入的 target 替换了原来 target 的位置。也就是说，当数组包含 target 时，插入点的索引就是该 target 的索引。</p>
</blockquote>
<ul>
<li>问题二：当数组中不存在 target 时，插入点是哪个元素的索引？</li>
</ul>
<blockquote>
<p>进一步思考二分查找过程：当 nums[m] &lt; target 时 ,first移动，这意味着指针first在向大于等于 target 的元素靠近。同理，指针last始终在向小于等于 target 的元素靠近。因此二分结束时一定有：first指向首个大于 target 的元素，last指向首个小于target 的元素。<strong>易得当数组不包含 target 时，插入索引为 first</strong>。</p>
</blockquote>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_insertion_simple</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">  <span class="string">&quot;&quot;&quot;二分查找插入点（无重复元素）&quot;&quot;&quot;</span></span><br><span class="line">  i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 初始化双闭区间 [0, n-1]</span></span><br><span class="line">  <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">      m = (i + j) // <span class="number">2</span>  <span class="comment"># 计算中点索引 m</span></span><br><span class="line">      <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">          i = m + <span class="number">1</span>  <span class="comment"># target 在区间 [m+1, j] 中</span></span><br><span class="line">      <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">          j = m - <span class="number">1</span>  <span class="comment"># target 在区间 [i, m-1] 中</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">return</span> m  <span class="comment"># 找到 target ，返回插入点 m</span></span><br><span class="line">  <span class="comment"># 未找到 target ，返回插入点 i</span></span><br><span class="line">  <span class="keyword">return</span> i</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码的思路很简单，也就是如果我们找到目标值，返回他的索引，如果没有找到，返回first （第一个大于目标索引的位置）的索引作为插入的位置</p>
</blockquote>
<h5 id="存在重复元素的情况"><a href="#存在重复元素的情况" class="headerlink" title="存在重复元素的情况"></a>存在重复元素的情况</h5><blockquote>
<p>在上一题的基础上，规定数组包含重复元素 </p>
</blockquote>
<p>假设数组中存在多个 target ，则普通二分查找只能返回其中一个 target 的索引，而无法确定该元素的左边和右边还有多少 target。<br>题目要求将目标元素插入到最左边，所以我们需要查找数组中最左一个 target 的索引</p>
<p>考虑拓展二分查找的代码，整体的流程不变</p>
<ul>
<li><p>当num[mid] &lt; target 或者 num[mid] &gt; target 的时候，操作不改变<br>让first 和 last 往taregt 的方向靠近</p>
</li>
<li><p>当num[mid] &#x3D;&#x3D; target 说明小于target 的元素在区间[first,m-1]中，因此采用j&#x3D;m-1 来进行缩小去边，使得last 向小于target 的元素靠近。</p>
</li>
<li><p>在实际的代码中，当target &lt; nums[mid] 的操作与 target &#x3D;&#x3D; nums[mid] 的操作相同，可以合成。</p>
</li>
</ul>
<p>循环完成之后，first 会指向最左边的target ，j 指向首个小于target 的元素。first 就是插入点</p>
<img src="C:\Users\86151\Pictures\Screenshots\屏幕截图 2024-10-23 174910.png" alt="屏幕截图 2024-10-23 174910" style="zoom:50%;" />

<img src="C:\Users\86151\Pictures\Screenshots\屏幕截图 2024-10-23 174939.png" alt="屏幕截图 2024-10-23 174939" style="zoom:50%;" />

<img src="C:\Users\86151\Pictures\Screenshots\屏幕截图 2024-10-23 175001.png" alt="屏幕截图 2024-10-23 175001" style="zoom:50%;" />

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_insertion</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">  <span class="string">&quot;&quot;&quot;二分查找插入点（存在重复元素）&quot;&quot;&quot;</span></span><br><span class="line">  i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 初始化双闭区间 [0, n-1]</span></span><br><span class="line">  <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">      m = (i + j) // <span class="number">2</span>  <span class="comment"># 计算中点索引 m</span></span><br><span class="line">      <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">          i = m + <span class="number">1</span>  <span class="comment"># target 在区间 [m+1, j] 中</span></span><br><span class="line">      <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">          j = m - <span class="number">1</span>  <span class="comment"># target 在区间 [i, m-1] 中</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          j = m - <span class="number">1</span>  <span class="comment"># 首个小于 target 的元素在区间 [i, m-1] 中</span></span><br><span class="line">  <span class="comment"># 返回插入点 i</span></span><br><span class="line">  <span class="keyword">return</span> i</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码的逻辑也是很清晰，当我们找到一个target 的时候是不会返回索引，而是<strong>缩减区间</strong>，继续向左边界搜索，直到最后，first 指向最左边的目标元素的位置。</p>
</blockquote>
<h4 id="二分查找边界"><a href="#二分查找边界" class="headerlink" title="二分查找边界"></a>二分查找边界</h4><blockquote>
<p>给定一个长度为n 的有序数组nums ，其中可能包含重复元素。请返回数组最左边一个元素target 的索引。若数组中不包含该元素，则返回-1</p>
</blockquote>
<h5 id="查找左边界"><a href="#查找左边界" class="headerlink" title="查找左边界"></a>查找左边界</h5><p>查找左边界实际上就是查找最左边的一个目标的索引，也就是我们可以使用上面寻找插入点的函数实现左边界。</p>
<p>但是需要注意的是，<strong>寻找插入点</strong>的时候，我们不管她有没有这个元素，都会返回一个适合她的索引。而这一题要求的是，当没有给元素的时候要返回-1</p>
<p>没有该元素的时候会有两种情况：</p>
<ul>
<li><p>插入点的索引越界</p>
</li>
<li><p>元素nums[i] 与target 不相等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_left_edge</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">  <span class="string">&quot;&quot;&quot;二分查找最左一个 target&quot;&quot;&quot;</span></span><br><span class="line">  <span class="comment"># 等价于查找 target 的插入点</span></span><br><span class="line">  i = binary_search_insertion(nums, target)</span><br><span class="line">  <span class="comment"># 未找到 target ，返回 -1</span></span><br><span class="line">  <span class="keyword">if</span> i == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[i] != target:</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  <span class="comment"># 找到 target ，返回索引 i</span></span><br><span class="line">  <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="寻找右边界"><a href="#寻找右边界" class="headerlink" title="寻找右边界"></a>寻找右边界</h5><p>最直接的办法是修改<strong>寻找插入点</strong> 函数代码中 当num[mid] &#x3D;&#x3D; target 的时候的边界缩减的方向。</p>
<ul>
<li>可以将其转化为查找最左边的数值为target+1  的索引。这个时候last 所指向小于等于目标元素的位置，所以最后结果返回last</li>
</ul>
<p><img src="C:\Users\86151\Pictures\Screenshots\binary_search_right_edge_by_left_edge.png"></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search_right_edge</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">  <span class="string">&quot;&quot;&quot;二分查找最右一个 target&quot;&quot;&quot;</span></span><br><span class="line">  <span class="comment"># 转化为查找最左一个 target + 1</span></span><br><span class="line">  i = binary_search_insertion(nums, target + <span class="number">1</span>)</span><br><span class="line">  <span class="comment"># j 指向最右一个 target ，i 指向首个大于 target 的元素</span></span><br><span class="line">  j = i - <span class="number">1</span></span><br><span class="line">  <span class="comment"># 未找到 target ，返回 -1</span></span><br><span class="line">  <span class="keyword">if</span> j == -<span class="number">1</span> <span class="keyword">or</span> nums[j] != target:</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  <span class="comment"># 找到 target ，返回索引 j</span></span><br><span class="line">  <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当目标元素不存在的时候，<strong>first 和 last 分别会指向首个大于，小于 该目标元素的元素</strong> </p>
</blockquote>
<ul>
<li>转化为查找元素<br>查找最左一个 target ：可以转化为查找 target - 0.5 ，并返回指针 first</li>
</ul>
<p>查找最右一个 target ：可以转化为查找 target + 0.5 ，并返回指针 last</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cs61b-acwing/">cs61b acwing</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imge.cc/2024/09/06/66d9e1e8bfa67.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/23/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="软件工程基础"><img class="cover" src="https://pic.imge.cc/2024/09/06/66d9e209cd2a2.gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">软件工程基础</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/06/linux/" title="linux"><img class="cover" src="https://pic.imge.cc/2024/09/06/66d9e18f5bbd4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">linux</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic.imge.cc/2024/09/05/66d9a7e532c09.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Larissa</div><div class="author-info__description">不是每个人都能功成名就,不妨在日常生活的点滴中寻找生命的意义</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Larissani/Larissani.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Larissani" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">复杂性分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">常用表示方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text">空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%EF%BC%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">数组，链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.2.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.3.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.4.</span> <span class="toc-text">访问操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.5.</span> <span class="toc-text">查找操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">栈，队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">3.1.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.1.</span> <span class="toc-text">栈的常用操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">3.1.2.</span> <span class="toc-text">基于链表实现栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">3.1.3.</span> <span class="toc-text">基于数组实现栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">3.2.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">3.2.1.</span> <span class="toc-text">基于链表实现队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">3.2.2.</span> <span class="toc-text">基于数组实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">另外一种写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97"><span class="toc-number">3.3.</span> <span class="toc-text">双向队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E5%88%97%E8%A1%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.1.</span> <span class="toc-text">双向列表的常用操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97"><span class="toc-number">3.3.2.</span> <span class="toc-text">基于双向链表实现双向队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.</span> <span class="toc-text">哈希表常用操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">哈希表的简单实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">4.3.</span> <span class="toc-text">哈希冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E4%BE%A6%E6%B5%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">线性侦测</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.1.</span> <span class="toc-text">二叉树的一些概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">5.1.2.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.3.</span> <span class="toc-text">常见二叉树类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.</span> <span class="toc-text">二叉树遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.1.</span> <span class="toc-text">前序遍历和后序遍历的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">5.3.</span> <span class="toc-text">二叉树的数组表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%AE%8C%E7%BE%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.3.1.</span> <span class="toc-text">表示完美二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E4%BB%BB%E6%84%8F%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.3.2.</span> <span class="toc-text">表示任意的二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">5.4.</span> <span class="toc-text">二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">5.4.1.</span> <span class="toc-text">二叉树的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">查找节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">插入节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">5.4.1.3.</span> <span class="toc-text">删除节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9C%89%E5%BA%8F"><span class="toc-number">5.4.1.4.</span> <span class="toc-text">中序遍历有序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AVL%E6%A0%91"><span class="toc-number">5.5.</span> <span class="toc-text">AVL树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD"><span class="toc-number">5.5.1.</span> <span class="toc-text">常见术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL-%E6%A0%91%E6%97%8B%E8%BD%AC"><span class="toc-number">5.5.2.</span> <span class="toc-text">AVL 树旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LL"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">LL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RR"><span class="toc-number">5.5.2.2.</span> <span class="toc-text">RR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR"><span class="toc-number">5.5.2.3.</span> <span class="toc-text">LR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RL"><span class="toc-number">5.5.2.4.</span> <span class="toc-text">RL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL%E6%A0%91%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">5.5.3.</span> <span class="toc-text">AVL树常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-1"><span class="toc-number">5.5.3.1.</span> <span class="toc-text">插入节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9-1"><span class="toc-number">5.5.3.2.</span> <span class="toc-text">删除节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-number">5.6.</span> <span class="toc-text">习题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%AF%B9%E7%A7%B0%EF%BC%8C%E5%B9%B3%E8%A1%A1%EF%BC%8C%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-number">5.6.1.</span> <span class="toc-text">二叉树相同，对称，平衡，右视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">5.6.2.</span> <span class="toc-text">验证二叉树是不是二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">5.6.3.</span> <span class="toc-text">最近公共祖先</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">6.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.1.</span> <span class="toc-text">堆的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E5%A0%86%E6%93%8D%E4%BD%9C"><span class="toc-number">6.2.</span> <span class="toc-text">建堆操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9%E5%85%A5%E5%A0%86%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.1.</span> <span class="toc-text">借助入堆操作实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9%E9%81%8D%E5%8E%86%E5%A0%86%E5%8C%96"><span class="toc-number">6.2.2.</span> <span class="toc-text">借助遍历堆化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#top-k-%E9%97%AE%E9%A2%98"><span class="toc-number">6.3.</span> <span class="toc-text">top-k 问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">7.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">7.1.</span> <span class="toc-text">术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">7.1.1.</span> <span class="toc-text">图的表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">7.2.</span> <span class="toc-text">图的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">7.2.1.</span> <span class="toc-text">对邻接矩阵的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.2.2.</span> <span class="toc-text">对邻接表的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">7.3.</span> <span class="toc-text">图的遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7%E7%BB%B4%E5%BA%A6"><span class="toc-number">8.1.</span> <span class="toc-text">评价维度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python-%E5%86%85%E7%BD%AE%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">python 内置排序函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F-1"><span class="toc-number">8.3.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">8.3.1.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">算法特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">8.3.2.</span> <span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E4%BC%98%E5%8C%96"><span class="toc-number">8.3.2.1.</span> <span class="toc-text">效率优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7-1"><span class="toc-number">8.3.2.2.</span> <span class="toc-text">算法特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">8.3.3.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7-2"><span class="toc-number">8.3.3.1.</span> <span class="toc-text">算法特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">8.3.4.</span> <span class="toc-text">快速排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">9.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E7%82%B9"><span class="toc-number">9.0.0.1.</span> <span class="toc-text">二分查找插入点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">9.0.0.1.1.</span> <span class="toc-text">无重复元素的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">9.0.0.1.2.</span> <span class="toc-text">存在重复元素的情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%BE%B9%E7%95%8C"><span class="toc-number">9.0.0.2.</span> <span class="toc-text">二分查找边界</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%B7%A6%E8%BE%B9%E7%95%8C"><span class="toc-number">9.0.0.2.1.</span> <span class="toc-text">查找左边界</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%8F%B3%E8%BE%B9%E7%95%8C"><span class="toc-number">9.0.0.2.2.</span> <span class="toc-text">寻找右边界</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/03/%E8%93%9D%E6%A1%A5/" title="蓝桥"><img src="https://pic.imge.cc/2024/09/06/66d9e209cd2a2.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="蓝桥"/></a><div class="content"><a class="title" href="/2025/03/03/%E8%93%9D%E6%A1%A5/" title="蓝桥">蓝桥</a><time datetime="2025-03-03T04:49:13.000Z" title="发表于 2025-03-03 12:49:13">2025-03-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/23/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="软件工程基础"><img src="https://pic.imge.cc/2024/09/06/66d9e209cd2a2.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件工程基础"/></a><div class="content"><a class="title" href="/2024/09/23/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="软件工程基础">软件工程基础</a><time datetime="2024-09-23T07:51:30.000Z" title="发表于 2024-09-23 15:51:30">2024-09-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="数据结构与算法"><img src="https://pic.imge.cc/2024/09/06/66d9e1e8bfa67.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构与算法"/></a><div class="content"><a class="title" href="/2024/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="数据结构与算法">数据结构与算法</a><time datetime="2024-09-09T07:35:48.000Z" title="发表于 2024-09-09 15:35:48">2024-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/06/linux/" title="linux"><img src="https://pic.imge.cc/2024/09/06/66d9e18f5bbd4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux"/></a><div class="content"><a class="title" href="/2024/09/06/linux/" title="linux">linux</a><time datetime="2024-09-06T09:55:05.000Z" title="发表于 2024-09-06 17:55:05">2024-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/05/larinous-%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/" title="larinous 的碎碎念"><img src="https://pic.imge.cc/2024/09/06/66d9e18f5bbd4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="larinous 的碎碎念"/></a><div class="content"><a class="title" href="/2024/09/05/larinous-%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/" title="larinous 的碎碎念">larinous 的碎碎念</a><time datetime="2024-09-05T08:46:14.000Z" title="发表于 2024-09-05 16:46:14">2024-09-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://pic.imge.cc/2024/09/06/66d9e1e8bfa67.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Larissa</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到larissa的cs小宇宙!</div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>